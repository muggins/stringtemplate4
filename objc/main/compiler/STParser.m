/** \file
 *  This OBJC source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g
 *     -                            On : 2013-08-16 08:32:34
 *     -                for the parser : STParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// $ANTLR 3.4 /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g 2013-08-16 08:32:34


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "STParser.h"
/* ----------------------------------------- */

/** Build an AST from a single StringTemplate template */

/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */

#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_template_in_templateAndEOF190;
static const unsigned long long FOLLOW_template_in_templateAndEOF190_data[] = { 0x0000000000000000LL};
static ANTLRBitSet *FOLLOW_EOF_in_templateAndEOF192;
static const unsigned long long FOLLOW_EOF_in_templateAndEOF192_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_element_in_template206;
static const unsigned long long FOLLOW_element_in_template206_data[] = { 0x000000C300000102LL};
static ANTLRBitSet *FOLLOW_INDENT_in_element224;
static const unsigned long long FOLLOW_INDENT_in_element224_data[] = { 0x0000000000000100LL};
static ANTLRBitSet *FOLLOW_COMMENT_in_element227;
static const unsigned long long FOLLOW_COMMENT_in_element227_data[] = { 0x0000008000000000LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_element229;
static const unsigned long long FOLLOW_NEWLINE_in_element229_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_INDENT_in_element242;
static const unsigned long long FOLLOW_INDENT_in_element242_data[] = { 0x0000008300000100LL};
static ANTLRBitSet *FOLLOW_singleElement_in_element244;
static const unsigned long long FOLLOW_singleElement_in_element244_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_singleElement_in_element266;
static const unsigned long long FOLLOW_singleElement_in_element266_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_compoundElement_in_element276;
static const unsigned long long FOLLOW_compoundElement_in_element276_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_exprTag_in_singleElement295;
static const unsigned long long FOLLOW_exprTag_in_singleElement295_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_TEXT_in_singleElement305;
static const unsigned long long FOLLOW_TEXT_in_singleElement305_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_singleElement315;
static const unsigned long long FOLLOW_NEWLINE_in_singleElement315_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_COMMENT_in_singleElement325;
static const unsigned long long FOLLOW_COMMENT_in_singleElement325_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ifstat_in_compoundElement346;
static const unsigned long long FOLLOW_ifstat_in_compoundElement346_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_region_in_compoundElement356;
static const unsigned long long FOLLOW_region_in_compoundElement356_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_exprTag375;
static const unsigned long long FOLLOW_LDELIM_in_exprTag375_data[] = { 0x0000010040417050LL};
static ANTLRBitSet *FOLLOW_expr_in_exprTag377;
static const unsigned long long FOLLOW_expr_in_exprTag377_data[] = { 0x0000000400800000LL};
static ANTLRBitSet *FOLLOW_SEMI_in_exprTag381;
static const unsigned long long FOLLOW_SEMI_in_exprTag381_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_exprOptions_in_exprTag383;
static const unsigned long long FOLLOW_exprOptions_in_exprTag383_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_exprTag388;
static const unsigned long long FOLLOW_RDELIM_in_exprTag388_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_INDENT_in_region434;
static const unsigned long long FOLLOW_INDENT_in_region434_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_region439;
static const unsigned long long FOLLOW_LDELIM_in_region439_data[] = { 0x0000010000000000LL};
static ANTLRBitSet *FOLLOW_AT_in_region441;
static const unsigned long long FOLLOW_AT_in_region441_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_region443;
static const unsigned long long FOLLOW_ID_in_region443_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_region445;
static const unsigned long long FOLLOW_RDELIM_in_region445_data[] = { 0x000000C300000100LL};
static ANTLRBitSet *FOLLOW_template_in_region457;
static const unsigned long long FOLLOW_template_in_region457_data[] = { 0x0000004200000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_region467;
static const unsigned long long FOLLOW_INDENT_in_region467_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_region470;
static const unsigned long long FOLLOW_LDELIM_in_region470_data[] = { 0x0000020000000000LL};
static ANTLRBitSet *FOLLOW_END_in_region472;
static const unsigned long long FOLLOW_END_in_region472_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_region474;
static const unsigned long long FOLLOW_RDELIM_in_region474_data[] = { 0x0000008000000002LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_region498;
static const unsigned long long FOLLOW_NEWLINE_in_region498_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LCURLY_in_subtemplate600;
static const unsigned long long FOLLOW_LCURLY_in_subtemplate600_data[] = { 0x000000C380000110LL};
static ANTLRBitSet *FOLLOW_ID_in_subtemplate606;
static const unsigned long long FOLLOW_ID_in_subtemplate606_data[] = { 0x0000000810000000LL};
static ANTLRBitSet *FOLLOW_COMMA_in_subtemplate610;
static const unsigned long long FOLLOW_COMMA_in_subtemplate610_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_subtemplate615;
static const unsigned long long FOLLOW_ID_in_subtemplate615_data[] = { 0x0000000810000000LL};
static ANTLRBitSet *FOLLOW_PIPE_in_subtemplate620;
static const unsigned long long FOLLOW_PIPE_in_subtemplate620_data[] = { 0x000000C380000100LL};
static ANTLRBitSet *FOLLOW_template_in_subtemplate625;
static const unsigned long long FOLLOW_template_in_subtemplate625_data[] = { 0x0000004080000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_subtemplate627;
static const unsigned long long FOLLOW_INDENT_in_subtemplate627_data[] = { 0x0000000080000000LL};
static ANTLRBitSet *FOLLOW_RCURLY_in_subtemplate630;
static const unsigned long long FOLLOW_RCURLY_in_subtemplate630_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat691;
static const unsigned long long FOLLOW_INDENT_in_ifstat691_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat694;
static const unsigned long long FOLLOW_LDELIM_in_ifstat694_data[] = { 0x0000000000040000LL};
static ANTLRBitSet *FOLLOW_IF_in_ifstat696;
static const unsigned long long FOLLOW_IF_in_ifstat696_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_ifstat698;
static const unsigned long long FOLLOW_LPAREN_in_ifstat698_data[] = { 0x0000010041417050LL};
static ANTLRBitSet *FOLLOW_conditional_in_ifstat702;
static const unsigned long long FOLLOW_conditional_in_ifstat702_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_ifstat704;
static const unsigned long long FOLLOW_RPAREN_in_ifstat704_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat706;
static const unsigned long long FOLLOW_RDELIM_in_ifstat706_data[] = { 0x000000C300000100LL};
static ANTLRBitSet *FOLLOW_template_in_ifstat724;
static const unsigned long long FOLLOW_template_in_ifstat724_data[] = { 0x0000004200000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat740;
static const unsigned long long FOLLOW_INDENT_in_ifstat740_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat743;
static const unsigned long long FOLLOW_LDELIM_in_ifstat743_data[] = { 0x0000000000100000LL};
static ANTLRBitSet *FOLLOW_ELSEIF_in_ifstat745;
static const unsigned long long FOLLOW_ELSEIF_in_ifstat745_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_ifstat747;
static const unsigned long long FOLLOW_LPAREN_in_ifstat747_data[] = { 0x0000010041417050LL};
static ANTLRBitSet *FOLLOW_conditional_in_ifstat751;
static const unsigned long long FOLLOW_conditional_in_ifstat751_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_ifstat753;
static const unsigned long long FOLLOW_RPAREN_in_ifstat753_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat755;
static const unsigned long long FOLLOW_RDELIM_in_ifstat755_data[] = { 0x000000C300000100LL};
static ANTLRBitSet *FOLLOW_template_in_ifstat759;
static const unsigned long long FOLLOW_template_in_ifstat759_data[] = { 0x0000004200000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat778;
static const unsigned long long FOLLOW_INDENT_in_ifstat778_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat781;
static const unsigned long long FOLLOW_LDELIM_in_ifstat781_data[] = { 0x0000000000080000LL};
static ANTLRBitSet *FOLLOW_ELSE_in_ifstat783;
static const unsigned long long FOLLOW_ELSE_in_ifstat783_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat785;
static const unsigned long long FOLLOW_RDELIM_in_ifstat785_data[] = { 0x000000C300000100LL};
static ANTLRBitSet *FOLLOW_template_in_ifstat789;
static const unsigned long long FOLLOW_template_in_ifstat789_data[] = { 0x0000004200000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat806;
static const unsigned long long FOLLOW_INDENT_in_ifstat806_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat812;
static const unsigned long long FOLLOW_LDELIM_in_ifstat812_data[] = { 0x0000000000200000LL};
static ANTLRBitSet *FOLLOW_ENDIF_in_ifstat814;
static const unsigned long long FOLLOW_ENDIF_in_ifstat814_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat824;
static const unsigned long long FOLLOW_RDELIM_in_ifstat824_data[] = { 0x0000008000000002LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_ifstat847;
static const unsigned long long FOLLOW_NEWLINE_in_ifstat847_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_andConditional_in_conditional991;
static const unsigned long long FOLLOW_andConditional_in_conditional991_data[] = { 0x0000001000000002LL};
static ANTLRBitSet *FOLLOW_OR_in_conditional995;
static const unsigned long long FOLLOW_OR_in_conditional995_data[] = { 0x0000010041417050LL};
static ANTLRBitSet *FOLLOW_andConditional_in_conditional998;
static const unsigned long long FOLLOW_andConditional_in_conditional998_data[] = { 0x0000001000000002LL};
static ANTLRBitSet *FOLLOW_notConditional_in_andConditional1014;
static const unsigned long long FOLLOW_notConditional_in_andConditional1014_data[] = { 0x0000002000000002LL};
static ANTLRBitSet *FOLLOW_AND_in_andConditional1018;
static const unsigned long long FOLLOW_AND_in_andConditional1018_data[] = { 0x0000010041417050LL};
static ANTLRBitSet *FOLLOW_notConditional_in_andConditional1021;
static const unsigned long long FOLLOW_notConditional_in_andConditional1021_data[] = { 0x0000002000000002LL};
static ANTLRBitSet *FOLLOW_BANG_in_notConditional1039;
static const unsigned long long FOLLOW_BANG_in_notConditional1039_data[] = { 0x0000010041417050LL};
static ANTLRBitSet *FOLLOW_notConditional_in_notConditional1042;
static const unsigned long long FOLLOW_notConditional_in_notConditional1042_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_notConditional1052;
static const unsigned long long FOLLOW_memberExpr_in_notConditional1052_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_notConditionalExpr1072;
static const unsigned long long FOLLOW_ID_in_notConditionalExpr1072_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_DOT_in_notConditionalExpr1091;
static const unsigned long long FOLLOW_DOT_in_notConditionalExpr1091_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_notConditionalExpr1095;
static const unsigned long long FOLLOW_ID_in_notConditionalExpr1095_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_DOT_in_notConditionalExpr1146;
static const unsigned long long FOLLOW_DOT_in_notConditionalExpr1146_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_notConditionalExpr1148;
static const unsigned long long FOLLOW_LPAREN_in_notConditionalExpr1148_data[] = { 0x0000010040417050LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_notConditionalExpr1150;
static const unsigned long long FOLLOW_mapExpr_in_notConditionalExpr1150_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_notConditionalExpr1152;
static const unsigned long long FOLLOW_RPAREN_in_notConditionalExpr1152_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_option_in_exprOptions1202;
static const unsigned long long FOLLOW_option_in_exprOptions1202_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_exprOptions1206;
static const unsigned long long FOLLOW_COMMA_in_exprOptions1206_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_option_in_exprOptions1208;
static const unsigned long long FOLLOW_option_in_exprOptions1208_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_ID_in_option1240;
static const unsigned long long FOLLOW_ID_in_option1240_data[] = { 0x0000000004000002LL};
static ANTLRBitSet *FOLLOW_EQUALS_in_option1264;
static const unsigned long long FOLLOW_EQUALS_in_option1264_data[] = { 0x0000010040417050LL};
static ANTLRBitSet *FOLLOW_exprNoComma_in_option1266;
static const unsigned long long FOLLOW_exprNoComma_in_option1266_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_exprNoComma1554;
static const unsigned long long FOLLOW_memberExpr_in_exprNoComma1554_data[] = { 0x0000000008000002LL};
static ANTLRBitSet *FOLLOW_COLON_in_exprNoComma1566;
static const unsigned long long FOLLOW_COLON_in_exprNoComma1566_data[] = { 0x0000000040010010LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_exprNoComma1568;
static const unsigned long long FOLLOW_mapTemplateRef_in_exprNoComma1568_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_expr1672;
static const unsigned long long FOLLOW_mapExpr_in_expr1672_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_mapExpr1689;
static const unsigned long long FOLLOW_memberExpr_in_mapExpr1689_data[] = { 0x0000000018000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_mapExpr1704;
static const unsigned long long FOLLOW_COMMA_in_mapExpr1704_data[] = { 0x0000010040417050LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_mapExpr1706;
static const unsigned long long FOLLOW_memberExpr_in_mapExpr1706_data[] = { 0x0000000018000000LL};
static ANTLRBitSet *FOLLOW_COLON_in_mapExpr1712;
static const unsigned long long FOLLOW_COLON_in_mapExpr1712_data[] = { 0x0000000040010010LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_mapExpr1714;
static const unsigned long long FOLLOW_mapTemplateRef_in_mapExpr1714_data[] = { 0x0000000008000002LL};
static ANTLRBitSet *FOLLOW_COLON_in_mapExpr1871;
static const unsigned long long FOLLOW_COLON_in_mapExpr1871_data[] = { 0x0000000040010010LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_mapExpr1875;
static const unsigned long long FOLLOW_mapTemplateRef_in_mapExpr1875_data[] = { 0x0000000018000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_mapExpr1881;
static const unsigned long long FOLLOW_COMMA_in_mapExpr1881_data[] = { 0x0000000040010010LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_mapExpr1885;
static const unsigned long long FOLLOW_mapTemplateRef_in_mapExpr1885_data[] = { 0x0000000018000002LL};
static ANTLRBitSet *FOLLOW_ID_in_mapTemplateRef1982;
static const unsigned long long FOLLOW_ID_in_mapTemplateRef1982_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_mapTemplateRef1984;
static const unsigned long long FOLLOW_LPAREN_in_mapTemplateRef1984_data[] = { 0x0000010042437050LL};
static ANTLRBitSet *FOLLOW_args_in_mapTemplateRef1986;
static const unsigned long long FOLLOW_args_in_mapTemplateRef1986_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_mapTemplateRef1988;
static const unsigned long long FOLLOW_RPAREN_in_mapTemplateRef1988_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_subtemplate_in_mapTemplateRef2033;
static const unsigned long long FOLLOW_subtemplate_in_mapTemplateRef2033_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_mapTemplateRef2045;
static const unsigned long long FOLLOW_LPAREN_in_mapTemplateRef2045_data[] = { 0x0000010040417050LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_mapTemplateRef2047;
static const unsigned long long FOLLOW_mapExpr_in_mapTemplateRef2047_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_mapTemplateRef2051;
static const unsigned long long FOLLOW_RPAREN_in_mapTemplateRef2051_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_mapTemplateRef2053;
static const unsigned long long FOLLOW_LPAREN_in_mapTemplateRef2053_data[] = { 0x0000010040437050LL};
static ANTLRBitSet *FOLLOW_argExprList_in_mapTemplateRef2055;
static const unsigned long long FOLLOW_argExprList_in_mapTemplateRef2055_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_mapTemplateRef2058;
static const unsigned long long FOLLOW_RPAREN_in_mapTemplateRef2058_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_includeExpr_in_memberExpr2089;
static const unsigned long long FOLLOW_includeExpr_in_memberExpr2089_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_DOT_in_memberExpr2108;
static const unsigned long long FOLLOW_DOT_in_memberExpr2108_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_memberExpr2110;
static const unsigned long long FOLLOW_ID_in_memberExpr2110_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_DOT_in_memberExpr2165;
static const unsigned long long FOLLOW_DOT_in_memberExpr2165_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_memberExpr2167;
static const unsigned long long FOLLOW_LPAREN_in_memberExpr2167_data[] = { 0x0000010040417050LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_memberExpr2169;
static const unsigned long long FOLLOW_mapExpr_in_memberExpr2169_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_memberExpr2171;
static const unsigned long long FOLLOW_RPAREN_in_memberExpr2171_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2246;
static const unsigned long long FOLLOW_ID_in_includeExpr2246_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2248;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2248_data[] = { 0x0000010040437050LL};
static ANTLRBitSet *FOLLOW_expr_in_includeExpr2250;
static const unsigned long long FOLLOW_expr_in_includeExpr2250_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2253;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2253_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_SUPER_in_includeExpr2297;
static const unsigned long long FOLLOW_SUPER_in_includeExpr2297_data[] = { 0x0000000020000000LL};
static ANTLRBitSet *FOLLOW_DOT_in_includeExpr2299;
static const unsigned long long FOLLOW_DOT_in_includeExpr2299_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2301;
static const unsigned long long FOLLOW_ID_in_includeExpr2301_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2303;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2303_data[] = { 0x0000010042437050LL};
static ANTLRBitSet *FOLLOW_args_in_includeExpr2305;
static const unsigned long long FOLLOW_args_in_includeExpr2305_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2307;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2307_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2340;
static const unsigned long long FOLLOW_ID_in_includeExpr2340_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2342;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2342_data[] = { 0x0000010042437050LL};
static ANTLRBitSet *FOLLOW_args_in_includeExpr2344;
static const unsigned long long FOLLOW_args_in_includeExpr2344_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2346;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2346_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_AT_in_includeExpr2391;
static const unsigned long long FOLLOW_AT_in_includeExpr2391_data[] = { 0x0000000000400000LL};
static ANTLRBitSet *FOLLOW_SUPER_in_includeExpr2393;
static const unsigned long long FOLLOW_SUPER_in_includeExpr2393_data[] = { 0x0000000020000000LL};
static ANTLRBitSet *FOLLOW_DOT_in_includeExpr2395;
static const unsigned long long FOLLOW_DOT_in_includeExpr2395_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2397;
static const unsigned long long FOLLOW_ID_in_includeExpr2397_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2399;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2399_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2403;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2403_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_AT_in_includeExpr2431;
static const unsigned long long FOLLOW_AT_in_includeExpr2431_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2433;
static const unsigned long long FOLLOW_ID_in_includeExpr2433_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2435;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2435_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2439;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2439_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_primary_in_includeExpr2479;
static const unsigned long long FOLLOW_primary_in_includeExpr2479_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_primary2498;
static const unsigned long long FOLLOW_ID_in_primary2498_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_STRING_in_primary2508;
static const unsigned long long FOLLOW_STRING_in_primary2508_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_T_TRUE_in_primary2518;
static const unsigned long long FOLLOW_T_TRUE_in_primary2518_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_T_FALSE_in_primary2528;
static const unsigned long long FOLLOW_T_FALSE_in_primary2528_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_subtemplate_in_primary2538;
static const unsigned long long FOLLOW_subtemplate_in_primary2538_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_list_in_primary2548;
static const unsigned long long FOLLOW_list_in_primary2548_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_primary2562;
static const unsigned long long FOLLOW_LPAREN_in_primary2562_data[] = { 0x0000010041417050LL};
static ANTLRBitSet *FOLLOW_conditional_in_primary2565;
static const unsigned long long FOLLOW_conditional_in_primary2565_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_primary2567;
static const unsigned long long FOLLOW_RPAREN_in_primary2567_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_primary2583;
static const unsigned long long FOLLOW_LPAREN_in_primary2583_data[] = { 0x0000010040417050LL};
static ANTLRBitSet *FOLLOW_expr_in_primary2585;
static const unsigned long long FOLLOW_expr_in_primary2585_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_primary2587;
static const unsigned long long FOLLOW_RPAREN_in_primary2587_data[] = { 0x0000000000010002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_primary2601;
static const unsigned long long FOLLOW_LPAREN_in_primary2601_data[] = { 0x0000010040437050LL};
static ANTLRBitSet *FOLLOW_argExprList_in_primary2603;
static const unsigned long long FOLLOW_argExprList_in_primary2603_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_primary2606;
static const unsigned long long FOLLOW_RPAREN_in_primary2606_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_argExprList_in_args2714;
static const unsigned long long FOLLOW_argExprList_in_args2714_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_namedArg_in_args2724;
static const unsigned long long FOLLOW_namedArg_in_args2724_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_args2728;
static const unsigned long long FOLLOW_COMMA_in_args2728_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_namedArg_in_args2730;
static const unsigned long long FOLLOW_namedArg_in_args2730_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_args2736;
static const unsigned long long FOLLOW_COMMA_in_args2736_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_ELLIPSIS_in_args2738;
static const unsigned long long FOLLOW_ELLIPSIS_in_args2738_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ELLIPSIS_in_args2758;
static const unsigned long long FOLLOW_ELLIPSIS_in_args2758_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_arg_in_argExprList2777;
static const unsigned long long FOLLOW_arg_in_argExprList2777_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_argExprList2781;
static const unsigned long long FOLLOW_COMMA_in_argExprList2781_data[] = { 0x0000010040417050LL};
static ANTLRBitSet *FOLLOW_arg_in_argExprList2783;
static const unsigned long long FOLLOW_arg_in_argExprList2783_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_exprNoComma_in_arg2800;
static const unsigned long long FOLLOW_exprNoComma_in_arg2800_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_namedArg2809;
static const unsigned long long FOLLOW_ID_in_namedArg2809_data[] = { 0x0000000004000000LL};
static ANTLRBitSet *FOLLOW_EQUALS_in_namedArg2811;
static const unsigned long long FOLLOW_EQUALS_in_namedArg2811_data[] = { 0x0000010040417050LL};
static ANTLRBitSet *FOLLOW_arg_in_namedArg2813;
static const unsigned long long FOLLOW_arg_in_namedArg2813_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LBRACK_in_list2846;
static const unsigned long long FOLLOW_LBRACK_in_list2846_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RBRACK_in_list2848;
static const unsigned long long FOLLOW_RBRACK_in_list2848_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LBRACK_in_list2865;
static const unsigned long long FOLLOW_LBRACK_in_list2865_data[] = { 0x000001005041F050LL};
static ANTLRBitSet *FOLLOW_listElement_in_list2867;
static const unsigned long long FOLLOW_listElement_in_list2867_data[] = { 0x0000000010008000LL};
static ANTLRBitSet *FOLLOW_COMMA_in_list2871;
static const unsigned long long FOLLOW_COMMA_in_list2871_data[] = { 0x000001005041F050LL};
static ANTLRBitSet *FOLLOW_listElement_in_list2873;
static const unsigned long long FOLLOW_listElement_in_list2873_data[] = { 0x0000000010008000LL};
static ANTLRBitSet *FOLLOW_RBRACK_in_list2878;
static const unsigned long long FOLLOW_RBRACK_in_list2878_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_exprNoComma_in_listElement2901;
static const unsigned long long FOLLOW_exprNoComma_in_listElement2901_data[] = { 0x0000000000000002LL};


#pragma mark Dynamic Global globalAttributeScopeImplementation

#pragma mark Dynamic Rule Scopes ruleAttributeScopeImplementation
@implementation conditional_Scope  /* start of ruleAttributeScopeImplementation */
@synthesize inside; 

+ (conditional_Scope *)newconditional_Scope
{
return [[conditional_Scope alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* start of conditional_Scope get and set functions */
- (BOOL)getinside { return( inside ); }
- (void)setinside:(BOOL)aVal { inside = aVal; }

/* End of conditional_Scope get and set functions */
@end /* end of ruleAttributeScopeImplementation */



#pragma mark Rule Return Scopes returnScopeImplementation
@implementation STParser_templateAndEOF_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_templateAndEOF_return *)newSTParser_templateAndEOF_return
{
return [[STParser_templateAndEOF_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_template_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_template_return *)newSTParser_template_return
{
return [[STParser_template_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_element_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_element_return *)newSTParser_element_return
{
return [[STParser_element_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_singleElement_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_singleElement_return *)newSTParser_singleElement_return
{
return [[STParser_singleElement_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_compoundElement_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_compoundElement_return *)newSTParser_compoundElement_return
{
return [[STParser_compoundElement_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_exprTag_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_exprTag_return *)newSTParser_exprTag_return
{
return [[STParser_exprTag_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_region_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_region_return *)newSTParser_region_return
{
return [[STParser_region_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_subtemplate_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_subtemplate_return *)newSTParser_subtemplate_return
{
return [[STParser_subtemplate_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_ifstat_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_ifstat_return *)newSTParser_ifstat_return
{
return [[STParser_ifstat_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_conditional_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_conditional_return *)newSTParser_conditional_return
{
return [[STParser_conditional_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_andConditional_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_andConditional_return *)newSTParser_andConditional_return
{
return [[STParser_andConditional_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_notConditional_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_notConditional_return *)newSTParser_notConditional_return
{
return [[STParser_notConditional_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_notConditionalExpr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_notConditionalExpr_return *)newSTParser_notConditionalExpr_return
{
return [[STParser_notConditionalExpr_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_exprOptions_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_exprOptions_return *)newSTParser_exprOptions_return
{
return [[STParser_exprOptions_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_option_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_option_return *)newSTParser_option_return
{
return [[STParser_option_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_exprNoComma_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_exprNoComma_return *)newSTParser_exprNoComma_return
{
return [[STParser_exprNoComma_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_expr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_expr_return *)newSTParser_expr_return
{
return [[STParser_expr_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_mapExpr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_mapExpr_return *)newSTParser_mapExpr_return
{
return [[STParser_mapExpr_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_mapTemplateRef_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_mapTemplateRef_return *)newSTParser_mapTemplateRef_return
{
return [[STParser_mapTemplateRef_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_memberExpr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_memberExpr_return *)newSTParser_memberExpr_return
{
return [[STParser_memberExpr_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_includeExpr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_includeExpr_return *)newSTParser_includeExpr_return
{
return [[STParser_includeExpr_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_primary_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_primary_return *)newSTParser_primary_return
{
return [[STParser_primary_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_args_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_args_return *)newSTParser_args_return
{
return [[STParser_args_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_argExprList_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_argExprList_return *)newSTParser_argExprList_return
{
return [[STParser_argExprList_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_arg_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_arg_return *)newSTParser_arg_return
{
return [[STParser_arg_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_namedArg_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_namedArg_return *)newSTParser_namedArg_return
{
return [[STParser_namedArg_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_list_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_list_return *)newSTParser_list_return
{
return [[STParser_list_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */

@implementation STParser_listElement_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_listElement_return *)newSTParser_listElement_return
{
return [[STParser_listElement_return alloc] init];
}

- (id) init
{
self = [super init];
return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    tree = aTree;
}

- (void) dealloc
{
    self.tree = nil;
    // [super dealloc];
}


@end /* end of returnScope implementation */



@implementation STParser  // line 637

#pragma mark global Attribute Scopes globalAttributeScope
/* ObjC start globalAttributeScope */
/* ObjC end globalAttributeScope */
/* ObjC start actions.(actionScope).synthesize */

@synthesize conditional_scope;
@synthesize errMgr;
@synthesize templateToken;

/* ObjC start synthesize() */
/* AST genericParser.synthesize */
/* AST parserProperties */
@synthesize treeAdaptor;

+ (void) initialize
{
    #pragma mark Bitsets
    FOLLOW_template_in_templateAndEOF190 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_templateAndEOF190_data Count:(NSUInteger)1];
    FOLLOW_EOF_in_templateAndEOF192 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_EOF_in_templateAndEOF192_data Count:(NSUInteger)1];
    FOLLOW_element_in_template206 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_element_in_template206_data Count:(NSUInteger)1];
    FOLLOW_INDENT_in_element224 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_element224_data Count:(NSUInteger)1];
    FOLLOW_COMMENT_in_element227 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMENT_in_element227_data Count:(NSUInteger)1];
    FOLLOW_NEWLINE_in_element229 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_element229_data Count:(NSUInteger)1];
    FOLLOW_INDENT_in_element242 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_element242_data Count:(NSUInteger)1];
    FOLLOW_singleElement_in_element244 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_singleElement_in_element244_data Count:(NSUInteger)1];
    FOLLOW_singleElement_in_element266 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_singleElement_in_element266_data Count:(NSUInteger)1];
    FOLLOW_compoundElement_in_element276 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_compoundElement_in_element276_data Count:(NSUInteger)1];
    FOLLOW_exprTag_in_singleElement295 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprTag_in_singleElement295_data Count:(NSUInteger)1];
    FOLLOW_TEXT_in_singleElement305 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_TEXT_in_singleElement305_data Count:(NSUInteger)1];
    FOLLOW_NEWLINE_in_singleElement315 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_singleElement315_data Count:(NSUInteger)1];
    FOLLOW_COMMENT_in_singleElement325 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMENT_in_singleElement325_data Count:(NSUInteger)1];
    FOLLOW_ifstat_in_compoundElement346 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ifstat_in_compoundElement346_data Count:(NSUInteger)1];
    FOLLOW_region_in_compoundElement356 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_region_in_compoundElement356_data Count:(NSUInteger)1];
    FOLLOW_LDELIM_in_exprTag375 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_exprTag375_data Count:(NSUInteger)1];
    FOLLOW_expr_in_exprTag377 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_exprTag377_data Count:(NSUInteger)1];
    FOLLOW_SEMI_in_exprTag381 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_SEMI_in_exprTag381_data Count:(NSUInteger)1];
    FOLLOW_exprOptions_in_exprTag383 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprOptions_in_exprTag383_data Count:(NSUInteger)1];
    FOLLOW_RDELIM_in_exprTag388 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_exprTag388_data Count:(NSUInteger)1];
    FOLLOW_INDENT_in_region434 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_region434_data Count:(NSUInteger)1];
    FOLLOW_LDELIM_in_region439 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_region439_data Count:(NSUInteger)1];
    FOLLOW_AT_in_region441 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_AT_in_region441_data Count:(NSUInteger)1];
    FOLLOW_ID_in_region443 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_region443_data Count:(NSUInteger)1];
    FOLLOW_RDELIM_in_region445 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_region445_data Count:(NSUInteger)1];
    FOLLOW_template_in_region457 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_region457_data Count:(NSUInteger)1];
    FOLLOW_INDENT_in_region467 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_region467_data Count:(NSUInteger)1];
    FOLLOW_LDELIM_in_region470 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_region470_data Count:(NSUInteger)1];
    FOLLOW_END_in_region472 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_END_in_region472_data Count:(NSUInteger)1];
    FOLLOW_RDELIM_in_region474 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_region474_data Count:(NSUInteger)1];
    FOLLOW_NEWLINE_in_region498 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_region498_data Count:(NSUInteger)1];
    FOLLOW_LCURLY_in_subtemplate600 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LCURLY_in_subtemplate600_data Count:(NSUInteger)1];
    FOLLOW_ID_in_subtemplate606 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_subtemplate606_data Count:(NSUInteger)1];
    FOLLOW_COMMA_in_subtemplate610 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_subtemplate610_data Count:(NSUInteger)1];
    FOLLOW_ID_in_subtemplate615 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_subtemplate615_data Count:(NSUInteger)1];
    FOLLOW_PIPE_in_subtemplate620 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_PIPE_in_subtemplate620_data Count:(NSUInteger)1];
    FOLLOW_template_in_subtemplate625 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_subtemplate625_data Count:(NSUInteger)1];
    FOLLOW_INDENT_in_subtemplate627 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_subtemplate627_data Count:(NSUInteger)1];
    FOLLOW_RCURLY_in_subtemplate630 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RCURLY_in_subtemplate630_data Count:(NSUInteger)1];
    FOLLOW_INDENT_in_ifstat691 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat691_data Count:(NSUInteger)1];
    FOLLOW_LDELIM_in_ifstat694 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat694_data Count:(NSUInteger)1];
    FOLLOW_IF_in_ifstat696 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_IF_in_ifstat696_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_ifstat698 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_ifstat698_data Count:(NSUInteger)1];
    FOLLOW_conditional_in_ifstat702 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_conditional_in_ifstat702_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_ifstat704 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_ifstat704_data Count:(NSUInteger)1];
    FOLLOW_RDELIM_in_ifstat706 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat706_data Count:(NSUInteger)1];
    FOLLOW_template_in_ifstat724 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_ifstat724_data Count:(NSUInteger)1];
    FOLLOW_INDENT_in_ifstat740 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat740_data Count:(NSUInteger)1];
    FOLLOW_LDELIM_in_ifstat743 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat743_data Count:(NSUInteger)1];
    FOLLOW_ELSEIF_in_ifstat745 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ELSEIF_in_ifstat745_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_ifstat747 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_ifstat747_data Count:(NSUInteger)1];
    FOLLOW_conditional_in_ifstat751 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_conditional_in_ifstat751_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_ifstat753 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_ifstat753_data Count:(NSUInteger)1];
    FOLLOW_RDELIM_in_ifstat755 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat755_data Count:(NSUInteger)1];
    FOLLOW_template_in_ifstat759 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_ifstat759_data Count:(NSUInteger)1];
    FOLLOW_INDENT_in_ifstat778 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat778_data Count:(NSUInteger)1];
    FOLLOW_LDELIM_in_ifstat781 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat781_data Count:(NSUInteger)1];
    FOLLOW_ELSE_in_ifstat783 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ELSE_in_ifstat783_data Count:(NSUInteger)1];
    FOLLOW_RDELIM_in_ifstat785 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat785_data Count:(NSUInteger)1];
    FOLLOW_template_in_ifstat789 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_ifstat789_data Count:(NSUInteger)1];
    FOLLOW_INDENT_in_ifstat806 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat806_data Count:(NSUInteger)1];
    FOLLOW_LDELIM_in_ifstat812 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat812_data Count:(NSUInteger)1];
    FOLLOW_ENDIF_in_ifstat814 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ENDIF_in_ifstat814_data Count:(NSUInteger)1];
    FOLLOW_RDELIM_in_ifstat824 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat824_data Count:(NSUInteger)1];
    FOLLOW_NEWLINE_in_ifstat847 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_ifstat847_data Count:(NSUInteger)1];
    FOLLOW_andConditional_in_conditional991 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_andConditional_in_conditional991_data Count:(NSUInteger)1];
    FOLLOW_OR_in_conditional995 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_OR_in_conditional995_data Count:(NSUInteger)1];
    FOLLOW_andConditional_in_conditional998 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_andConditional_in_conditional998_data Count:(NSUInteger)1];
    FOLLOW_notConditional_in_andConditional1014 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_notConditional_in_andConditional1014_data Count:(NSUInteger)1];
    FOLLOW_AND_in_andConditional1018 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_AND_in_andConditional1018_data Count:(NSUInteger)1];
    FOLLOW_notConditional_in_andConditional1021 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_notConditional_in_andConditional1021_data Count:(NSUInteger)1];
    FOLLOW_BANG_in_notConditional1039 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_BANG_in_notConditional1039_data Count:(NSUInteger)1];
    FOLLOW_notConditional_in_notConditional1042 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_notConditional_in_notConditional1042_data Count:(NSUInteger)1];
    FOLLOW_memberExpr_in_notConditional1052 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_notConditional1052_data Count:(NSUInteger)1];
    FOLLOW_ID_in_notConditionalExpr1072 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_notConditionalExpr1072_data Count:(NSUInteger)1];
    FOLLOW_DOT_in_notConditionalExpr1091 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_notConditionalExpr1091_data Count:(NSUInteger)1];
    FOLLOW_ID_in_notConditionalExpr1095 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_notConditionalExpr1095_data Count:(NSUInteger)1];
    FOLLOW_DOT_in_notConditionalExpr1146 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_notConditionalExpr1146_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_notConditionalExpr1148 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_notConditionalExpr1148_data Count:(NSUInteger)1];
    FOLLOW_mapExpr_in_notConditionalExpr1150 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_notConditionalExpr1150_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_notConditionalExpr1152 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_notConditionalExpr1152_data Count:(NSUInteger)1];
    FOLLOW_option_in_exprOptions1202 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_option_in_exprOptions1202_data Count:(NSUInteger)1];
    FOLLOW_COMMA_in_exprOptions1206 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_exprOptions1206_data Count:(NSUInteger)1];
    FOLLOW_option_in_exprOptions1208 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_option_in_exprOptions1208_data Count:(NSUInteger)1];
    FOLLOW_ID_in_option1240 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_option1240_data Count:(NSUInteger)1];
    FOLLOW_EQUALS_in_option1264 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_EQUALS_in_option1264_data Count:(NSUInteger)1];
    FOLLOW_exprNoComma_in_option1266 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprNoComma_in_option1266_data Count:(NSUInteger)1];
    FOLLOW_memberExpr_in_exprNoComma1554 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_exprNoComma1554_data Count:(NSUInteger)1];
    FOLLOW_COLON_in_exprNoComma1566 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COLON_in_exprNoComma1566_data Count:(NSUInteger)1];
    FOLLOW_mapTemplateRef_in_exprNoComma1568 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_exprNoComma1568_data Count:(NSUInteger)1];
    FOLLOW_mapExpr_in_expr1672 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_expr1672_data Count:(NSUInteger)1];
    FOLLOW_memberExpr_in_mapExpr1689 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_mapExpr1689_data Count:(NSUInteger)1];
    FOLLOW_COMMA_in_mapExpr1704 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_mapExpr1704_data Count:(NSUInteger)1];
    FOLLOW_memberExpr_in_mapExpr1706 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_mapExpr1706_data Count:(NSUInteger)1];
    FOLLOW_COLON_in_mapExpr1712 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COLON_in_mapExpr1712_data Count:(NSUInteger)1];
    FOLLOW_mapTemplateRef_in_mapExpr1714 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_mapExpr1714_data Count:(NSUInteger)1];
    FOLLOW_COLON_in_mapExpr1871 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COLON_in_mapExpr1871_data Count:(NSUInteger)1];
    FOLLOW_mapTemplateRef_in_mapExpr1875 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_mapExpr1875_data Count:(NSUInteger)1];
    FOLLOW_COMMA_in_mapExpr1881 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_mapExpr1881_data Count:(NSUInteger)1];
    FOLLOW_mapTemplateRef_in_mapExpr1885 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_mapExpr1885_data Count:(NSUInteger)1];
    FOLLOW_ID_in_mapTemplateRef1982 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_mapTemplateRef1982_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_mapTemplateRef1984 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_mapTemplateRef1984_data Count:(NSUInteger)1];
    FOLLOW_args_in_mapTemplateRef1986 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_args_in_mapTemplateRef1986_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_mapTemplateRef1988 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_mapTemplateRef1988_data Count:(NSUInteger)1];
    FOLLOW_subtemplate_in_mapTemplateRef2033 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_subtemplate_in_mapTemplateRef2033_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_mapTemplateRef2045 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_mapTemplateRef2045_data Count:(NSUInteger)1];
    FOLLOW_mapExpr_in_mapTemplateRef2047 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_mapTemplateRef2047_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_mapTemplateRef2051 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_mapTemplateRef2051_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_mapTemplateRef2053 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_mapTemplateRef2053_data Count:(NSUInteger)1];
    FOLLOW_argExprList_in_mapTemplateRef2055 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_argExprList_in_mapTemplateRef2055_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_mapTemplateRef2058 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_mapTemplateRef2058_data Count:(NSUInteger)1];
    FOLLOW_includeExpr_in_memberExpr2089 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_includeExpr_in_memberExpr2089_data Count:(NSUInteger)1];
    FOLLOW_DOT_in_memberExpr2108 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_memberExpr2108_data Count:(NSUInteger)1];
    FOLLOW_ID_in_memberExpr2110 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_memberExpr2110_data Count:(NSUInteger)1];
    FOLLOW_DOT_in_memberExpr2165 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_memberExpr2165_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_memberExpr2167 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_memberExpr2167_data Count:(NSUInteger)1];
    FOLLOW_mapExpr_in_memberExpr2169 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_memberExpr2169_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_memberExpr2171 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_memberExpr2171_data Count:(NSUInteger)1];
    FOLLOW_ID_in_includeExpr2246 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2246_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_includeExpr2248 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2248_data Count:(NSUInteger)1];
    FOLLOW_expr_in_includeExpr2250 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_includeExpr2250_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_includeExpr2253 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2253_data Count:(NSUInteger)1];
    FOLLOW_SUPER_in_includeExpr2297 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_SUPER_in_includeExpr2297_data Count:(NSUInteger)1];
    FOLLOW_DOT_in_includeExpr2299 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_includeExpr2299_data Count:(NSUInteger)1];
    FOLLOW_ID_in_includeExpr2301 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2301_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_includeExpr2303 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2303_data Count:(NSUInteger)1];
    FOLLOW_args_in_includeExpr2305 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_args_in_includeExpr2305_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_includeExpr2307 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2307_data Count:(NSUInteger)1];
    FOLLOW_ID_in_includeExpr2340 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2340_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_includeExpr2342 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2342_data Count:(NSUInteger)1];
    FOLLOW_args_in_includeExpr2344 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_args_in_includeExpr2344_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_includeExpr2346 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2346_data Count:(NSUInteger)1];
    FOLLOW_AT_in_includeExpr2391 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_AT_in_includeExpr2391_data Count:(NSUInteger)1];
    FOLLOW_SUPER_in_includeExpr2393 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_SUPER_in_includeExpr2393_data Count:(NSUInteger)1];
    FOLLOW_DOT_in_includeExpr2395 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_includeExpr2395_data Count:(NSUInteger)1];
    FOLLOW_ID_in_includeExpr2397 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2397_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_includeExpr2399 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2399_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_includeExpr2403 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2403_data Count:(NSUInteger)1];
    FOLLOW_AT_in_includeExpr2431 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_AT_in_includeExpr2431_data Count:(NSUInteger)1];
    FOLLOW_ID_in_includeExpr2433 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2433_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_includeExpr2435 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2435_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_includeExpr2439 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2439_data Count:(NSUInteger)1];
    FOLLOW_primary_in_includeExpr2479 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_primary_in_includeExpr2479_data Count:(NSUInteger)1];
    FOLLOW_ID_in_primary2498 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_primary2498_data Count:(NSUInteger)1];
    FOLLOW_STRING_in_primary2508 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_STRING_in_primary2508_data Count:(NSUInteger)1];
    FOLLOW_T_TRUE_in_primary2518 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_T_TRUE_in_primary2518_data Count:(NSUInteger)1];
    FOLLOW_T_FALSE_in_primary2528 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_T_FALSE_in_primary2528_data Count:(NSUInteger)1];
    FOLLOW_subtemplate_in_primary2538 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_subtemplate_in_primary2538_data Count:(NSUInteger)1];
    FOLLOW_list_in_primary2548 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_list_in_primary2548_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_primary2562 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_primary2562_data Count:(NSUInteger)1];
    FOLLOW_conditional_in_primary2565 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_conditional_in_primary2565_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_primary2567 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_primary2567_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_primary2583 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_primary2583_data Count:(NSUInteger)1];
    FOLLOW_expr_in_primary2585 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_primary2585_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_primary2587 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_primary2587_data Count:(NSUInteger)1];
    FOLLOW_LPAREN_in_primary2601 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_primary2601_data Count:(NSUInteger)1];
    FOLLOW_argExprList_in_primary2603 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_argExprList_in_primary2603_data Count:(NSUInteger)1];
    FOLLOW_RPAREN_in_primary2606 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_primary2606_data Count:(NSUInteger)1];
    FOLLOW_argExprList_in_args2714 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_argExprList_in_args2714_data Count:(NSUInteger)1];
    FOLLOW_namedArg_in_args2724 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_namedArg_in_args2724_data Count:(NSUInteger)1];
    FOLLOW_COMMA_in_args2728 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_args2728_data Count:(NSUInteger)1];
    FOLLOW_namedArg_in_args2730 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_namedArg_in_args2730_data Count:(NSUInteger)1];
    FOLLOW_COMMA_in_args2736 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_args2736_data Count:(NSUInteger)1];
    FOLLOW_ELLIPSIS_in_args2738 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ELLIPSIS_in_args2738_data Count:(NSUInteger)1];
    FOLLOW_ELLIPSIS_in_args2758 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ELLIPSIS_in_args2758_data Count:(NSUInteger)1];
    FOLLOW_arg_in_argExprList2777 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_arg_in_argExprList2777_data Count:(NSUInteger)1];
    FOLLOW_COMMA_in_argExprList2781 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_argExprList2781_data Count:(NSUInteger)1];
    FOLLOW_arg_in_argExprList2783 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_arg_in_argExprList2783_data Count:(NSUInteger)1];
    FOLLOW_exprNoComma_in_arg2800 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprNoComma_in_arg2800_data Count:(NSUInteger)1];
    FOLLOW_ID_in_namedArg2809 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_namedArg2809_data Count:(NSUInteger)1];
    FOLLOW_EQUALS_in_namedArg2811 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_EQUALS_in_namedArg2811_data Count:(NSUInteger)1];
    FOLLOW_arg_in_namedArg2813 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_arg_in_namedArg2813_data Count:(NSUInteger)1];
    FOLLOW_LBRACK_in_list2846 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LBRACK_in_list2846_data Count:(NSUInteger)1];
    FOLLOW_RBRACK_in_list2848 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RBRACK_in_list2848_data Count:(NSUInteger)1];
    FOLLOW_LBRACK_in_list2865 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LBRACK_in_list2865_data Count:(NSUInteger)1];
    FOLLOW_listElement_in_list2867 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_listElement_in_list2867_data Count:(NSUInteger)1];
    FOLLOW_COMMA_in_list2871 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_list2871_data Count:(NSUInteger)1];
    FOLLOW_listElement_in_list2873 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_listElement_in_list2873_data Count:(NSUInteger)1];
    FOLLOW_RBRACK_in_list2878 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RBRACK_in_list2878_data Count:(NSUInteger)1];
    FOLLOW_exprNoComma_in_listElement2901 = [ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprNoComma_in_listElement2901_data Count:(NSUInteger)1];

    [BaseRecognizer setTokenNames:[AMutableArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>", 
 @"ID", @"WS", @"STRING", @"ANONYMOUS_TEMPLATE", @"COMMENT", @"LINE_COMMENT", 
 @"BIGSTRING", @"BIGSTRING_NO_NL", @"T_FALSE", @"T_TRUE", @"LBRACK", @"RBRACK", 
 @"LPAREN", @"RPAREN", @"IF", @"ELSE", @"ELSEIF", @"ENDIF", @"SUPER", @"SEMI", 
 @"BANG", @"ELLIPSIS", @"EQUALS", @"COLON", @"COMMA", @"DOT", @"LCURLY", 
 @"RCURLY", @"TEXT", @"LDELIM", @"RDELIM", @"PIPE", @"OR", @"AND", @"INDENT", 
 @"NEWLINE", @"AT", @"END", @"ARGS", @"ELEMENTS", @"EXEC_FUNC", @"EXPR", 
 @"INCLUDE", @"INCLUDE_IND", @"INCLUDE_REGION", @"INCLUDE_SUPER", @"INCLUDE_SUPER_REGION", 
 @"INDENTED_EXPR", @"LIST", @"MAP", @"OPTIONS", @"PROP", @"PROP_IND", @"REGION", 
 @"SUBTEMPLATE", @"TNULL", @"TO_STR", @"ZIP", nil]];
    [BaseRecognizer setGrammarFileName:@"/Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g"];
}

+ (STParser *)newSTParser:(id<TokenStream>)aStream
{
    return [[STParser alloc] initWithTokenStream:aStream];
}

- (id) initWithTokenStream:(id<TokenStream>)aStream
{
    self = [super initWithTokenStream:aStream State:[RecognizerSharedState newRecognizerSharedStateWithRuleLen:28+1]];
    if ( self != nil ) {
        /* ruleAttributeScopeInit */
        conditional_scope = [conditional_Scope newconditional_Scope];
        conditional_stack = [SymbolStack newSymbolStackWithLen:30];

        /* start of actions-actionScope-init */
        /* start of init */
        /* AST genericParser.init */
        [self setTreeAdaptor:[CommonTreeAdaptor newTreeAdaptor]];
    }
    return self;
}

- (void) dealloc
{
    /* AST genericParser.dealloc */
    [self setTreeAdaptor:nil];

    // [super dealloc];
}

/* ObjC start actions.(actionScope).methods */

+ (id) newSTParser:(id<TokenStream>)anInput error:(ErrorManager *)anErrMgr token:(CommonToken *)aTemplateToken
{
    return [[STParser alloc] init:anInput error:anErrMgr token:aTemplateToken];
}

- (id) init:(id<TokenStream>)anInput error:(ErrorManager *)anErrMgr token:(CommonToken *)aTemplateToken
{
    self = [super initWithTokenStream:(id<TokenStream>)anInput];
    if ( self != nil ) {
        /* ruleAttributeScopeInit */
        conditional_scope = [conditional_Scope newconditional_Scope];
        conditional_stack = [SymbolStack newSymbolStackWithLen:30];
        [self setTreeAdaptor:[CommonTreeAdaptor newTreeAdaptor]];
        errMgr = anErrMgr;
        templateToken = aTemplateToken;
    }
    return self;
}

- (id) recoverFromMismatchedToken:(id<IntStream>)anInput TokenType:(NSInteger)ttype Follow:(ANTLRBitSet *)follow
{
    @throw [MismatchedTokenException newException:ttype Stream:anInput];
}

/* ObjC end actions.(actionScope).methods */
/* ObjC start methods() */
/* AST genericParser.methods */
/* AST parserMethods */
- (id<TreeAdaptor>) getTreeAdaptor
{
	return treeAdaptor;
}

- (void) setTreeAdaptor:(id<TreeAdaptor>)aTreeAdaptor
{
	if (aTreeAdaptor != treeAdaptor) {
		treeAdaptor = aTreeAdaptor;
	}
}
/* ObjC end methods() */
/* ObjC start rules */
/*
 * $ANTLR start templateAndEOF
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:110:1: templateAndEOF : template EOF -> ( template )? ;
 */
- (STParser_templateAndEOF_return *) templateAndEOF
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_templateAndEOF_return * retval = [STParser_templateAndEOF_return newSTParser_templateAndEOF_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *EOF2 = nil;

        STParser_template_return * template1 = nil ;



        CommonTree *EOF2_tree=nil;
        RewriteRuleTokenStream *stream_EOF =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token EOF"];
        RewriteRuleSubtreeStream *stream_template =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:110:16: ( template EOF -> ( template )? ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:110:18: template EOF // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_templateAndEOF190];
        template1 = [self template];

        [self popFollow];


        [stream_template addElement:[template1 getTree]];
         
        EOF2=(CommonToken *)[self match:input TokenType:EOF Follow:FOLLOW_EOF_in_templateAndEOF192];  
            [stream_EOF addElement:EOF2];

         
        // AST REWRITE
        // elements: template
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 110:31: -> ( template )?
        {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:110:34: ( template )?
            if ( [stream_template hasNext] ) {
            	[treeAdaptor addChild:[stream_template nextTree] toTree:root_0];

            }
            [stream_template reset];

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_EOF = nil;
        stream_template = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end templateAndEOF */

/*
 * $ANTLR start template
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:112:1: template : ( element )* ;
 */
- (STParser_template_return *) template
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_template_return * retval = [STParser_template_return newSTParser_template_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */


        STParser_element_return * element3 = nil ;




        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:112:10: ( ( element )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:112:12: ( element )* // alt
        {
        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];




        do {
            NSInteger alt1=2;
            switch ([input LA:1]) { // dfaLoopbackStateSwitch
                case INDENT: ;
                    {
                    NSInteger LA1_2 = [input LA:2];
                    if ( LA1_2==LDELIM ) {
                        NSInteger LA1_5 = [input LA:3];
                        if ( (LA1_5==ID||LA1_5==STRING||(LA1_5 >= T_FALSE && LA1_5 <= LBRACK)||LA1_5==LPAREN||LA1_5==IF||LA1_5==SUPER||LA1_5==LCURLY||LA1_5==AT) ) {
                            alt1=1;
                        }


                    }
                    else if ( (LA1_2==COMMENT||LA1_2==TEXT||LA1_2==NEWLINE) ) {
                        alt1=1;
                    }


                    }
                    break;
                case LDELIM: ;
                    {
                    NSInteger LA1_3 = [input LA:2];
                    if ( (LA1_3==ID||LA1_3==STRING||(LA1_3 >= T_FALSE && LA1_3 <= LBRACK)||LA1_3==LPAREN||LA1_3==IF||LA1_3==SUPER||LA1_3==LCURLY||LA1_3==AT) ) {
                        alt1=1;
                    }


                    }
                    break;
                case COMMENT: ;
                case TEXT: ;
                case NEWLINE: ;
                    {
                    alt1=1;
                    }
                    break;

            }

            switch (alt1) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:112:12: element // alt
                    {

                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_element_in_template206];
                    element3 = [self element];

                    [self popFollow];


                    [treeAdaptor addChild:[element3 getTree] toTree:root_0];
                     
                    }
                    break;

                default :
                    goto loop1;
            }
        } while (YES);
        loop1: ;

         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end template */

/*
 * $ANTLR start element
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:114:1: element : ({...}? ( INDENT )? COMMENT NEWLINE ->| INDENT singleElement -> ^( INDENTED_EXPR INDENT ( singleElement )? ) | singleElement | compoundElement );
 */
- (STParser_element_return *) element
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_element_return * retval = [STParser_element_return newSTParser_element_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *INDENT4 = nil;
        CommonToken *COMMENT5 = nil;
        CommonToken *NEWLINE6 = nil;
        CommonToken *INDENT7 = nil;

        STParser_singleElement_return * singleElement8 = nil ;

        STParser_singleElement_return * singleElement9 = nil ;

        STParser_compoundElement_return * compoundElement10 = nil ;



        CommonTree *INDENT4_tree=nil;
        CommonTree *COMMENT5_tree=nil;
        CommonTree *NEWLINE6_tree=nil;
        CommonTree *INDENT7_tree=nil;
        RewriteRuleTokenStream *stream_NEWLINE =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token NEWLINE"];
        RewriteRuleTokenStream *stream_COMMENT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMENT"];
        RewriteRuleTokenStream *stream_INDENT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"];
        RewriteRuleSubtreeStream *stream_singleElement =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule singleElement"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:115:5: ({...}? ( INDENT )? COMMENT NEWLINE ->| INDENT singleElement -> ^( INDENTED_EXPR INDENT ( singleElement )? ) | singleElement | compoundElement ) //ruleblock
        NSInteger alt3=4;
        unichar charLA3 = [input LA:1];
        switch (charLA3) {
            case INDENT: ;
                {
                unichar charLA3 = [input LA:2];
                switch (charLA3) {
                    case COMMENT: ;
                        {
                        NSInteger LA3_5 = [input LA:3];

                        if ( LA3_5==NEWLINE ) {
                            NSInteger LA3_11 = [input LA:4];

                            if ( [input LT:1].charPositionInLine == 0 ) {
                                alt3=1;
                            }
                            else if ( (YES) ) {
                                alt3=2;
                            }
                            else {
                                NoViableAltException *nvae = [NoViableAltException newException:3 state:11 stream:input];
                                nvae.c = LA3_11;
                                @throw nvae;

                            }
                        }
                        else if ( LA3_5==(unichar)EOF||LA3_5==COMMENT||(LA3_5 >= RCURLY && LA3_5 <= LDELIM)||LA3_5==INDENT ) {
                            alt3=2;
                        }
                        else {
                            NoViableAltException *nvae = [NoViableAltException newException:3 state:5 stream:input];
                            nvae.c = LA3_5;
                            nvae.token = [input LT:3];
                            @throw nvae;

                        }
                        }
                        break;
                    case LDELIM: ;
                        {
                        unichar charLA3 = [input LA:3];
                        switch (charLA3) {
                            case IF: ;
                                {
                                alt3=4;
                                }
                                break;
                            case AT: ;
                                {
                                NSInteger LA3_12 = [input LA:4];

                                if ( LA3_12==ID ) {
                                    NSInteger LA3_15 = [input LA:5];

                                    if ( LA3_15==RDELIM ) {
                                        alt3=4;
                                    }
                                    else if ( LA3_15==LPAREN ) {
                                        alt3=2;
                                    }
                                    else {
                                        NoViableAltException *nvae = [NoViableAltException newException:3 state:15 stream:input];
                                        nvae.c = LA3_15;
                                        @throw nvae;

                                    }
                                }
                                else if ( LA3_12==SUPER ) {
                                    alt3=2;
                                }
                                else {
                                    NoViableAltException *nvae = [NoViableAltException newException:3 state:12 stream:input];
                                    nvae.c = LA3_12;
                                    @throw nvae;

                                }
                                }
                                break;
                            case ID: ;
                            case STRING: ;
                            case T_FALSE: ;
                            case T_TRUE: ;
                            case LBRACK: ;
                            case LPAREN: ;
                            case SUPER: ;
                            case LCURLY: ;
                                {
                                alt3=2;
                                }
                                break;

                        default: ;
                            NoViableAltException *nvae = [NoViableAltException newException:3 state:6 stream:input];
                            nvae.c = charLA3;
                            @throw nvae;

                        }

                        }
                        break;
                    case TEXT: ;
                    case NEWLINE: ;
                        {
                        alt3=2;
                        }
                        break;

                default: ;
                    NoViableAltException *nvae = [NoViableAltException newException:3 state:1 stream:input];
                    nvae.c = charLA3;
                    @throw nvae;

                }

                }
                break;
            case COMMENT: ;
                {
                NSInteger LA3_2 = [input LA:2];

                if ( LA3_2==NEWLINE ) {
                    NSInteger LA3_8 = [input LA:3];

                    if ( (([input LT:1].charPositionInLine == 0 )) ) {
                        alt3=1;
                    }
                    else if ( (YES) ) {
                        alt3=3;
                    }
                    else {
                        NoViableAltException *nvae = [NoViableAltException newException:3 state:8 stream:input];
                        nvae.c = LA3_8;
                        @throw nvae;

                    }
                }
                else if ( LA3_2==(unichar)EOF||LA3_2==COMMENT||(LA3_2 >= RCURLY && LA3_2 <= LDELIM)||LA3_2==INDENT ) {
                    alt3=3;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:3 state:2 stream:input];
                    nvae.c = LA3_2;
                    @throw nvae;

                }
                }
                break;
            case LDELIM: ;
                {
                unichar charLA3 = [input LA:2];
                switch (charLA3) {
                    case IF: ;
                        {
                        alt3=4;
                        }
                        break;
                    case AT: ;
                        {
                        NSInteger LA3_10 = [input LA:3];

                        if ( LA3_10==ID ) {
                            NSInteger LA3_14 = [input LA:4];

                            if ( LA3_14==RDELIM ) {
                                alt3=4;
                            }
                            else if ( LA3_14==LPAREN ) {
                                alt3=3;
                            }
                            else {
                                NoViableAltException *nvae = [NoViableAltException newException:3 state:14 stream:input];
                                nvae.c = LA3_14;
                                @throw nvae;

                            }
                        }
                        else if ( LA3_10==SUPER ) {
                            alt3=3;
                        }
                        else {
                            NoViableAltException *nvae = [NoViableAltException newException:3 state:10 stream:input];
                            nvae.c = LA3_10;
                            @throw nvae;

                        }
                        }
                        break;
                    case ID: ;
                    case STRING: ;
                    case T_FALSE: ;
                    case T_TRUE: ;
                    case LBRACK: ;
                    case LPAREN: ;
                    case SUPER: ;
                    case LCURLY: ;
                        {
                        alt3=3;
                        }
                        break;

                default: ;
                    NoViableAltException *nvae = [NoViableAltException newException:3 state:3 stream:input];
                    nvae.c = charLA3;
                    @throw nvae;

                }

                }
                break;
            case TEXT: ;
            case NEWLINE: ;
                {
                alt3=3;
                }
                break;

        default: ;
            NoViableAltException *nvae = [NoViableAltException newException:3 state:0 stream:input];
            nvae.c = charLA3;
            @throw nvae;

        }

        switch (alt3) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:115:9: {...}? ( INDENT )? COMMENT NEWLINE // alt
                {

                if ( !(([input LT:1].charPositionInLine == 0 )) ) {
                    @throw [FailedPredicateException newException:@"element" predicate:@"[input LT:1].charPositionInLine == 0 " stream:input];
                }
                 
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:115:50: ( INDENT )? // block
                NSInteger alt2=2;
                NSInteger LA2_0 = [input LA:1];

                if ( LA2_0==INDENT ) {
                    alt2=1;
                }
                switch (alt2) {
                    case 1 : ;
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:115:50: INDENT // alt
                        {

                        INDENT4=(CommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_element224];  
                            [stream_INDENT addElement:INDENT4];

                         
                        }
                        break;

                }

                 
                COMMENT5=(CommonToken *)[self match:input TokenType:COMMENT Follow:FOLLOW_COMMENT_in_element227];  
                    [stream_COMMENT addElement:COMMENT5];

                 
                NEWLINE6=(CommonToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_element229];  
                    [stream_NEWLINE addElement:NEWLINE6];

                 
                // AST REWRITE
                // elements: 
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 115:74: ->
                {
                    root_0 = nil;
                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:116:9: INDENT singleElement // alt
                {

                INDENT7=(CommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_element242];  
                    [stream_INDENT addElement:INDENT7];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_singleElement_in_element244];
                singleElement8 = [self singleElement];

                [self popFollow];


                [stream_singleElement addElement:[singleElement8 getTree]];
                 
                // AST REWRITE
                // elements: singleElement, INDENT
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 116:30: -> ^( INDENTED_EXPR INDENT ( singleElement )? )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:116:33: ^( INDENTED_EXPR INDENT ( singleElement )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INDENTED_EXPR Text:@"INDENTED_EXPR"] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:[stream_INDENT nextNode] toTree:root_1];

                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:116:56: ( singleElement )?
                        if ( [stream_singleElement hasNext] ) {
                        	[treeAdaptor addChild:[stream_singleElement nextTree] toTree:root_1];

                        }
                        [stream_singleElement reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:117:9: singleElement // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_singleElement_in_element266];
                singleElement9 = [self singleElement];

                [self popFollow];


                [treeAdaptor addChild:[singleElement9 getTree] toTree:root_0];
                 
                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:118:9: compoundElement // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_compoundElement_in_element276];
                compoundElement10 = [self compoundElement];

                [self popFollow];


                [treeAdaptor addChild:[compoundElement10 getTree] toTree:root_0];
                 
                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_NEWLINE = nil;
        stream_COMMENT = nil;
        stream_INDENT = nil;
        stream_singleElement = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end element */

/*
 * $ANTLR start singleElement
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:121:1: singleElement : ( exprTag | TEXT | NEWLINE | COMMENT !);
 */
- (STParser_singleElement_return *) singleElement
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_singleElement_return * retval = [STParser_singleElement_return newSTParser_singleElement_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *TEXT12 = nil;
        CommonToken *NEWLINE13 = nil;
        CommonToken *COMMENT14 = nil;

        STParser_exprTag_return * exprTag11 = nil ;



        CommonTree *TEXT12_tree=nil;
        CommonTree *NEWLINE13_tree=nil;
        CommonTree *COMMENT14_tree=nil;

        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:122:5: ( exprTag | TEXT | NEWLINE | COMMENT !) //ruleblock
        NSInteger alt4=4;
        unichar charLA4 = [input LA:1];
        switch (charLA4) {
            case LDELIM: ;
                {
                alt4=1;
                }
                break;
            case TEXT: ;
                {
                alt4=2;
                }
                break;
            case NEWLINE: ;
                {
                alt4=3;
                }
                break;
            case COMMENT: ;
                {
                alt4=4;
                }
                break;

        default: ;
            NoViableAltException *nvae = [NoViableAltException newException:4 state:0 stream:input];
            nvae.c = charLA4;
            @throw nvae;

        }

        switch (alt4) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:122:9: exprTag // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_exprTag_in_singleElement295];
                exprTag11 = [self exprTag];

                [self popFollow];


                [treeAdaptor addChild:[exprTag11 getTree] toTree:root_0];
                 
                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:123:9: TEXT // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser tokenRef */
                TEXT12=(CommonToken *)[self match:input TokenType:TEXT Follow:FOLLOW_TEXT_in_singleElement305]; 
                TEXT12_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[treeAdaptor create:TEXT12]
                ;
                [treeAdaptor addChild:TEXT12_tree  toTree:root_0];

                 
                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:124:9: NEWLINE // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser tokenRef */
                NEWLINE13=(CommonToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_singleElement315]; 
                NEWLINE13_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[treeAdaptor create:NEWLINE13]
                ;
                [treeAdaptor addChild:NEWLINE13_tree  toTree:root_0];

                 
                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:125:9: COMMENT ! // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                COMMENT14=(CommonToken *)[self match:input TokenType:COMMENT Follow:FOLLOW_COMMENT_in_singleElement325]; 
                 
                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end singleElement */

/*
 * $ANTLR start compoundElement
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:128:1: compoundElement : ( ifstat | region );
 */
- (STParser_compoundElement_return *) compoundElement
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_compoundElement_return * retval = [STParser_compoundElement_return newSTParser_compoundElement_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */


        STParser_ifstat_return * ifstat15 = nil ;

        STParser_region_return * region16 = nil ;




        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:129:5: ( ifstat | region ) //ruleblock
        NSInteger alt5=2;
        NSInteger LA5_0 = [input LA:1];

        if ( LA5_0==INDENT ) {
            NSInteger LA5_1 = [input LA:2];

            if ( LA5_1==LDELIM ) {
                NSInteger LA5_2 = [input LA:3];

                if ( LA5_2==IF ) {
                    alt5=1;
                }
                else if ( LA5_2==AT ) {
                    alt5=2;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:5 state:2 stream:input];
                    nvae.c = LA5_2;
                    @throw nvae;

                }
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:5 state:1 stream:input];
                nvae.c = LA5_1;
                @throw nvae;

            }
        }
        else if ( LA5_0==LDELIM ) {
            NSInteger LA5_2 = [input LA:2];

            if ( LA5_2==IF ) {
                alt5=1;
            }
            else if ( LA5_2==AT ) {
                alt5=2;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:5 state:2 stream:input];
                nvae.c = LA5_2;
                @throw nvae;

            }
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:5 state:0 stream:input];
            nvae.c = LA5_0;
            @throw nvae;

        }
        switch (alt5) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:129:9: ifstat // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_ifstat_in_compoundElement346];
                ifstat15 = [self ifstat];

                [self popFollow];


                [treeAdaptor addChild:[ifstat15 getTree] toTree:root_0];
                 
                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:130:9: region // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_region_in_compoundElement356];
                region16 = [self region];

                [self popFollow];


                [treeAdaptor addChild:[region16 getTree] toTree:root_0];
                 
                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end compoundElement */

/*
 * $ANTLR start exprTag
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:133:1: exprTag : LDELIM expr ( ';' exprOptions )? RDELIM -> ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? ) ;
 */
- (STParser_exprTag_return *) exprTag
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_exprTag_return * retval = [STParser_exprTag_return newSTParser_exprTag_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *LDELIM17 = nil;
        CommonToken *char_literal19 = nil;
        CommonToken *RDELIM21 = nil;

        STParser_expr_return * expr18 = nil ;

        STParser_exprOptions_return * exprOptions20 = nil ;



        CommonTree *LDELIM17_tree=nil;
        CommonTree *char_literal19_tree=nil;
        CommonTree *RDELIM21_tree=nil;
        RewriteRuleTokenStream *stream_RDELIM =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RDELIM"];
        RewriteRuleTokenStream *stream_LDELIM =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LDELIM"];
        RewriteRuleTokenStream *stream_SEMI =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token SEMI"];
        RewriteRuleSubtreeStream *stream_exprOptions =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule exprOptions"];
        RewriteRuleSubtreeStream *stream_expr =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:134:5: ( LDELIM expr ( ';' exprOptions )? RDELIM -> ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:134:9: LDELIM expr ( ';' exprOptions )? RDELIM // alt
        {

        LDELIM17=(CommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_exprTag375];  
            [stream_LDELIM addElement:LDELIM17];

         
        /* ruleRef */
        [self pushFollow:FOLLOW_expr_in_exprTag377];
        expr18 = [self expr];

        [self popFollow];


        [stream_expr addElement:[expr18 getTree]];
         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:134:21: ( ';' exprOptions )? // block
        NSInteger alt6=2;
        NSInteger LA6_0 = [input LA:1];

        if ( LA6_0==SEMI ) {
            alt6=1;
        }
        switch (alt6) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:134:23: ';' exprOptions // alt
                {

                char_literal19=(CommonToken *)[self match:input TokenType:SEMI Follow:FOLLOW_SEMI_in_exprTag381];  
                    [stream_SEMI addElement:char_literal19];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_exprOptions_in_exprTag383];
                exprOptions20 = [self exprOptions];

                [self popFollow];


                [stream_exprOptions addElement:[exprOptions20 getTree]];
                 
                }
                break;

        }

         
        RDELIM21=(CommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_exprTag388];  
            [stream_RDELIM addElement:RDELIM21];

         
        // AST REWRITE
        // elements: exprOptions, expr
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 135:9: -> ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? )
        {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:135:12: ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? )
            {
                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:EXPR FromToken:LDELIM17 Text:@"EXPR"] old:root_1];

                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:135:41: ( exprOptions )?
                if ( [stream_exprOptions hasNext] ) {
                	[treeAdaptor addChild:[stream_exprOptions nextTree] toTree:root_1];

                }
                [stream_exprOptions reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_RDELIM = nil;
        stream_LDELIM = nil;
        stream_SEMI = nil;
        stream_exprOptions = nil;
        stream_expr = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end exprTag */

/*
 * $ANTLR start region
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:138:1: region : (i= INDENT )? x= LDELIM '@' ID RDELIM template ( INDENT )? LDELIM '@end' RDELIM ({...}? => NEWLINE )? -> {indent != nil}? ^( INDENTED_EXPR $i ^( REGION[$x] ID ( template )? ) ) -> ^( REGION[$x] ID ( template )? ) ;
 */
- (STParser_region_return *) region
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_region_return * retval = [STParser_region_return newSTParser_region_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

     CommonToken *indent=nil; 
    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *i = nil;
        CommonToken *x = nil;
        CommonToken *char_literal22 = nil;
        CommonToken *ID23 = nil;
        CommonToken *RDELIM24 = nil;
        CommonToken *INDENT26 = nil;
        CommonToken *LDELIM27 = nil;
        CommonToken *string_literal28 = nil;
        CommonToken *RDELIM29 = nil;
        CommonToken *NEWLINE30 = nil;

        STParser_template_return * template25 = nil ;



        CommonTree *i_tree=nil;
        CommonTree *x_tree=nil;
        CommonTree *char_literal22_tree=nil;
        CommonTree *ID23_tree=nil;
        CommonTree *RDELIM24_tree=nil;
        CommonTree *INDENT26_tree=nil;
        CommonTree *LDELIM27_tree=nil;
        CommonTree *string_literal28_tree=nil;
        CommonTree *RDELIM29_tree=nil;
        CommonTree *NEWLINE30_tree=nil;
        RewriteRuleTokenStream *stream_AT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token AT"];
        RewriteRuleTokenStream *stream_RDELIM =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RDELIM"];
        RewriteRuleTokenStream *stream_NEWLINE =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token NEWLINE"];
        RewriteRuleTokenStream *stream_ID =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"];
        RewriteRuleTokenStream *stream_END =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token END"];
        RewriteRuleTokenStream *stream_LDELIM =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LDELIM"];
        RewriteRuleTokenStream *stream_INDENT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"];
        RewriteRuleSubtreeStream *stream_template =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:140:5: ( (i= INDENT )? x= LDELIM '@' ID RDELIM template ( INDENT )? LDELIM '@end' RDELIM ({...}? => NEWLINE )? -> {indent != nil}? ^( INDENTED_EXPR $i ^( REGION[$x] ID ( template )? ) ) -> ^( REGION[$x] ID ( template )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:140:9: (i= INDENT )? x= LDELIM '@' ID RDELIM template ( INDENT )? LDELIM '@end' RDELIM ({...}? => NEWLINE )? // alt
        {

        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:140:10: (i= INDENT )? // block
        NSInteger alt7=2;
        NSInteger LA7_0 = [input LA:1];

        if ( LA7_0==INDENT ) {
            alt7=1;
        }
        switch (alt7) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:140:10: i= INDENT // alt
                {

                i=(CommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_region434];  
                    [stream_INDENT addElement:i];

                 
                }
                break;

        }

         
        x=(CommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_region439];  
            [stream_LDELIM addElement:x];

         
        char_literal22=(CommonToken *)[self match:input TokenType:AT Follow:FOLLOW_AT_in_region441];  
            [stream_AT addElement:char_literal22];

         
        ID23=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_region443];  
            [stream_ID addElement:ID23];

         
        RDELIM24=(CommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_region445];  
            [stream_RDELIM addElement:RDELIM24];

         

         if ([input LA:1] != NEWLINE) indent=i;

         
        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_region457];
        template25 = [self template];

        [self popFollow];


        [stream_template addElement:[template25 getTree]];
         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:142:9: ( INDENT )? // block
        NSInteger alt8=2;
        NSInteger LA8_0 = [input LA:1];

        if ( LA8_0==INDENT ) {
            alt8=1;
        }
        switch (alt8) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:142:9: INDENT // alt
                {

                INDENT26=(CommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_region467];  
                    [stream_INDENT addElement:INDENT26];

                 
                }
                break;

        }

         
        LDELIM27=(CommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_region470];  
            [stream_LDELIM addElement:LDELIM27];

         
        string_literal28=(CommonToken *)[self match:input TokenType:END Follow:FOLLOW_END_in_region472];  
            [stream_END addElement:string_literal28];

         
        RDELIM29=(CommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_region474];  
            [stream_RDELIM addElement:RDELIM29];

         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:144:9: ({...}? => NEWLINE )? // block
        NSInteger alt9=2;
        NSInteger LA9_0 = [input LA:1];

        if ( LA9_0==NEWLINE ) {
            NSInteger LA9_1 = [input LA:2];

            if ( ((((CommonToken *)retval.start).line != [input LT:1].line)) ) {
                alt9=1;
            }
        }
        switch (alt9) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:144:10: {...}? => NEWLINE // alt
                {

                if ( !((((CommonToken *)retval.start).line != [input LT:1].line)) ) {
                    @throw [FailedPredicateException newException:@"region" predicate:@"$region.start.line != [input LT:1].line" stream:input];
                }
                 
                NEWLINE30=(CommonToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_region498];  
                    [stream_NEWLINE addElement:NEWLINE30];

                 
                }
                break;

        }

         
        // AST REWRITE
        // elements: ID, template, ID, template, i
        // token labels: i
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleTokenStream *stream_i =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor description:@"token i" element:i];
        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 145:9: -> {indent != nil}? ^( INDENTED_EXPR $i ^( REGION[$x] ID ( template )? ) )
        if (indent != nil) {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:146:12: ^( INDENTED_EXPR $i ^( REGION[$x] ID ( template )? ) )
            {
                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INDENTED_EXPR Text:@"INDENTED_EXPR"] old:root_1];

                [treeAdaptor addChild:[stream_i nextNode] toTree:root_1];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:146:31: ^( REGION[$x] ID ( template )? )
                {
                    CommonTree *root_2 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                    root_2 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:REGION FromToken:x Text:@"REGION"] old:root_2];

                     // TODO: args: 
                    [treeAdaptor addChild:[stream_ID nextNode] toTree:root_2];

                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:146:47: ( template )?
                    if ( [stream_template hasNext] ) {
                    	[treeAdaptor addChild:[stream_template nextTree] toTree:root_2];

                    }
                    [stream_template reset];

                    [treeAdaptor addChild:root_2 toTree:root_1];
                }

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        else // 147:9: -> ^( REGION[$x] ID ( template )? )
        {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:147:31: ^( REGION[$x] ID ( template )? )
            {
                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:REGION FromToken:x Text:@"REGION"] old:root_1];

                 // TODO: args: 
                [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:147:47: ( template )?
                if ( [stream_template hasNext] ) {
                	[treeAdaptor addChild:[stream_template nextTree] toTree:root_1];

                }
                [stream_template reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_AT = nil;
        stream_RDELIM = nil;
        stream_NEWLINE = nil;
        stream_ID = nil;
        stream_END = nil;
        stream_LDELIM = nil;
        stream_INDENT = nil;
        stream_template = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end region */

/*
 * $ANTLR start subtemplate
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:150:1: subtemplate : lc= '{' (ids+= ID ( ',' ids+= ID )* '|' )? template ( INDENT )? '}' -> ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* ( template )? ) ;
 */
- (STParser_subtemplate_return *) subtemplate
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_subtemplate_return * retval = [STParser_subtemplate_return newSTParser_subtemplate_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *lc = nil;
        CommonToken *char_literal31 = nil;
        CommonToken *char_literal32 = nil;
        CommonToken *INDENT34 = nil;
        CommonToken *char_literal35 = nil;
        CommonToken *ids = nil;
        AMutableArray *list_ids = nil;
        STParser_template_return * template33 = nil ;



        CommonTree *lc_tree=nil;
        CommonTree *char_literal31_tree=nil;
        CommonTree *char_literal32_tree=nil;
        CommonTree *INDENT34_tree=nil;
        CommonTree *char_literal35_tree=nil;
        CommonTree *ids_tree = nil;
        RewriteRuleTokenStream *stream_LCURLY =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LCURLY"];
        RewriteRuleTokenStream *stream_PIPE =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token PIPE"];
        RewriteRuleTokenStream *stream_ID =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"];
        RewriteRuleTokenStream *stream_COMMA =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"];
        RewriteRuleTokenStream *stream_INDENT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"];
        RewriteRuleTokenStream *stream_RCURLY =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RCURLY"];
        RewriteRuleSubtreeStream *stream_template =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:151:5: (lc= '{' (ids+= ID ( ',' ids+= ID )* '|' )? template ( INDENT )? '}' -> ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* ( template )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:151:9: lc= '{' (ids+= ID ( ',' ids+= ID )* '|' )? template ( INDENT )? '}' // alt
        {

        lc=(CommonToken *)[self match:input TokenType:LCURLY Follow:FOLLOW_LCURLY_in_subtemplate600];  
            [stream_LCURLY addElement:lc];

         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:151:16: (ids+= ID ( ',' ids+= ID )* '|' )? // block
        NSInteger alt11=2;
        NSInteger LA11_0 = [input LA:1];

        if ( LA11_0==ID ) {
            alt11=1;
        }
        switch (alt11) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:151:17: ids+= ID ( ',' ids+= ID )* '|' // alt
                {

                ids=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_subtemplate606];  
                    [stream_ID addElement:ids];

                if (list_ids == nil) list_ids = [AMutableArray arrayWithCapacity:5];
                [list_ids addObject:ids];

                 

                do {
                    NSInteger alt10=2;
                    NSInteger LA10_0 = [input LA:1];
                    if ( LA10_0==COMMA ) {
                        alt10=1;
                    }


                    switch (alt10) {
                        case 1 : ;
                            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:151:28: ',' ids+= ID // alt
                            {

                            char_literal31=(CommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_subtemplate610];  
                                [stream_COMMA addElement:char_literal31];

                             
                            ids=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_subtemplate615];  
                                [stream_ID addElement:ids];

                            if (list_ids == nil) list_ids = [AMutableArray arrayWithCapacity:5];
                            [list_ids addObject:ids];

                             
                            }
                            break;

                        default :
                            goto loop10;
                    }
                } while (YES);
                loop10: ;

                 
                char_literal32=(CommonToken *)[self match:input TokenType:PIPE Follow:FOLLOW_PIPE_in_subtemplate620];  
                    [stream_PIPE addElement:char_literal32];

                 
                }
                break;

        }

         
        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_subtemplate625];
        template33 = [self template];

        [self popFollow];


        [stream_template addElement:[template33 getTree]];
         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:151:60: ( INDENT )? // block
        NSInteger alt12=2;
        NSInteger LA12_0 = [input LA:1];

        if ( LA12_0==INDENT ) {
            alt12=1;
        }
        switch (alt12) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:151:60: INDENT // alt
                {

                INDENT34=(CommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_subtemplate627];  
                    [stream_INDENT addElement:INDENT34];

                 
                }
                break;

        }

         
        char_literal35=(CommonToken *)[self match:input TokenType:RCURLY Follow:FOLLOW_RCURLY_in_subtemplate630];  
            [stream_RCURLY addElement:char_literal35];

         
        // AST REWRITE
        // elements: template, ids
        // token labels: 
        // rule labels: retval
        // token list labels: ids
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleTokenStream *stream_ids =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                description:@"token ids" elements:list_ids];
        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 153:9: -> ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* ( template )? )
        {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:153:12: ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* ( template )? )
            {
                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:SUBTEMPLATE FromToken:lc Text:@"SUBTEMPLATE"] old:root_1];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:153:46: ( ^( ARGS $ids) )*
                while ( [stream_ids hasNext] ) {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:153:46: ^( ARGS $ids)
                    {
                        CommonTree *root_2 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_2 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:ARGS Text:@"ARGS"] old:root_2];

                        [treeAdaptor addChild:[stream_ids nextNode] toTree:root_2];

                        [treeAdaptor addChild:root_2 toTree:root_1];
                    }

                }
                [stream_ids reset];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:153:60: ( template )?
                if ( [stream_template hasNext] ) {
                	[treeAdaptor addChild:[stream_template nextTree] toTree:root_1];

                }
                [stream_template reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        list_ids = nil;
        [retval setStop:[input LT:-1]];


        stream_LCURLY = nil;
        stream_PIPE = nil;
        stream_ID = nil;
        stream_COMMA = nil;
        stream_INDENT = nil;
        stream_RCURLY = nil;
        stream_template = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end subtemplate */

/*
 * $ANTLR start ifstat
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:156:1: ifstat : (i= INDENT )? LDELIM 'if' '(' c1= conditional ')' RDELIM t1= template ( ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template )* ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? ( INDENT )? endif= LDELIM 'endif' RDELIM ({...}? => NEWLINE )? -> {indent!=nil}? ^( INDENTED_EXPR $i ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ) -> ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ;
 */
- (STParser_ifstat_return *) ifstat
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_ifstat_return * retval = [STParser_ifstat_return newSTParser_ifstat_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    CommonToken *indent = nil;
    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *i = nil;
        CommonToken *endif = nil;
        CommonToken *LDELIM36 = nil;
        CommonToken *string_literal37 = nil;
        CommonToken *char_literal38 = nil;
        CommonToken *char_literal39 = nil;
        CommonToken *RDELIM40 = nil;
        CommonToken *INDENT41 = nil;
        CommonToken *LDELIM42 = nil;
        CommonToken *string_literal43 = nil;
        CommonToken *char_literal44 = nil;
        CommonToken *char_literal45 = nil;
        CommonToken *RDELIM46 = nil;
        CommonToken *INDENT47 = nil;
        CommonToken *LDELIM48 = nil;
        CommonToken *string_literal49 = nil;
        CommonToken *RDELIM50 = nil;
        CommonToken *INDENT51 = nil;
        CommonToken *string_literal52 = nil;
        CommonToken *RDELIM53 = nil;
        CommonToken *NEWLINE54 = nil;
        AMutableArray *list_c2 = nil;
        AMutableArray *list_t2 = nil;
        STParser_conditional_return * c1 = nil ;

        STParser_template_return * t1 = nil ;

        STParser_template_return * t3 = nil ;

        ParserRuleReturnScope *c2 = nil;
        ParserRuleReturnScope *t2 = nil;

        CommonTree *i_tree=nil;
        CommonTree *endif_tree=nil;
        CommonTree *LDELIM36_tree=nil;
        CommonTree *string_literal37_tree=nil;
        CommonTree *char_literal38_tree=nil;
        CommonTree *char_literal39_tree=nil;
        CommonTree *RDELIM40_tree=nil;
        CommonTree *INDENT41_tree=nil;
        CommonTree *LDELIM42_tree=nil;
        CommonTree *string_literal43_tree=nil;
        CommonTree *char_literal44_tree=nil;
        CommonTree *char_literal45_tree=nil;
        CommonTree *RDELIM46_tree=nil;
        CommonTree *INDENT47_tree=nil;
        CommonTree *LDELIM48_tree=nil;
        CommonTree *string_literal49_tree=nil;
        CommonTree *RDELIM50_tree=nil;
        CommonTree *INDENT51_tree=nil;
        CommonTree *string_literal52_tree=nil;
        CommonTree *RDELIM53_tree=nil;
        CommonTree *NEWLINE54_tree=nil;
        RewriteRuleTokenStream *stream_ENDIF =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ENDIF"];
        RewriteRuleTokenStream *stream_RDELIM =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RDELIM"];
        RewriteRuleTokenStream *stream_RPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"];
        RewriteRuleTokenStream *stream_NEWLINE =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token NEWLINE"];
        RewriteRuleTokenStream *stream_LDELIM =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LDELIM"];
        RewriteRuleTokenStream *stream_INDENT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"];
        RewriteRuleTokenStream *stream_LPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"];
        RewriteRuleTokenStream *stream_IF =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token IF"];
        RewriteRuleTokenStream *stream_ELSE =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ELSE"];
        RewriteRuleTokenStream *stream_ELSEIF =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ELSEIF"];
        RewriteRuleSubtreeStream *stream_template =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"];
        RewriteRuleSubtreeStream *stream_conditional =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule conditional"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:158:5: ( (i= INDENT )? LDELIM 'if' '(' c1= conditional ')' RDELIM t1= template ( ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template )* ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? ( INDENT )? endif= LDELIM 'endif' RDELIM ({...}? => NEWLINE )? -> {indent!=nil}? ^( INDENTED_EXPR $i ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ) -> ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:158:9: (i= INDENT )? LDELIM 'if' '(' c1= conditional ')' RDELIM t1= template ( ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template )* ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? ( INDENT )? endif= LDELIM 'endif' RDELIM ({...}? => NEWLINE )? // alt
        {

        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:158:10: (i= INDENT )? // block
        NSInteger alt13=2;
        NSInteger LA13_0 = [input LA:1];

        if ( LA13_0==INDENT ) {
            alt13=1;
        }
        switch (alt13) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:158:10: i= INDENT // alt
                {

                i=(CommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat691];  
                    [stream_INDENT addElement:i];

                 
                }
                break;

        }

         
        LDELIM36=(CommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat694];  
            [stream_LDELIM addElement:LDELIM36];

         
        string_literal37=(CommonToken *)[self match:input TokenType:IF Follow:FOLLOW_IF_in_ifstat696];  
            [stream_IF addElement:string_literal37];

         
        char_literal38=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_ifstat698];  
            [stream_LPAREN addElement:char_literal38];

         
        /* ruleRef */
        [self pushFollow:FOLLOW_conditional_in_ifstat702];
        c1 = [self conditional];

        [self popFollow];


        [stream_conditional addElement:[c1 getTree]];
         
        char_literal39=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_ifstat704];  
            [stream_RPAREN addElement:char_literal39];

         
        RDELIM40=(CommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat706];  
            [stream_RDELIM addElement:RDELIM40];

         

        if ([input LA:1]!=NEWLINE) indent=i;

         
        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_ifstat724];
        t1 = [self template];

        [self popFollow];


        [stream_template addElement:[t1 getTree]];
         

        do {
            NSInteger alt15=2;
            NSInteger LA15_0 = [input LA:1];
            if ( LA15_0==INDENT ) {
                NSInteger LA15_1 = [input LA:2];
                if ( LA15_1==LDELIM ) {
                    NSInteger LA15_2 = [input LA:3];
                    if ( LA15_2==ELSEIF ) {
                        alt15=1;
                    }


                }


            }
            else if ( LA15_0==LDELIM ) {
                NSInteger LA15_2 = [input LA:2];
                if ( LA15_2==ELSEIF ) {
                    alt15=1;
                }


            }


            switch (alt15) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:160:15: ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template // alt
                    {

                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:160:15: ( INDENT )? // block
                    NSInteger alt14=2;
                    NSInteger LA14_0 = [input LA:1];

                    if ( LA14_0==INDENT ) {
                        alt14=1;
                    }
                    switch (alt14) {
                        case 1 : ;
                            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:160:15: INDENT // alt
                            {

                            INDENT41=(CommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat740];  
                                [stream_INDENT addElement:INDENT41];

                             
                            }
                            break;

                    }

                     
                    LDELIM42=(CommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat743];  
                        [stream_LDELIM addElement:LDELIM42];

                     
                    string_literal43=(CommonToken *)[self match:input TokenType:ELSEIF Follow:FOLLOW_ELSEIF_in_ifstat745];  
                        [stream_ELSEIF addElement:string_literal43];

                     
                    char_literal44=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_ifstat747];  
                        [stream_LPAREN addElement:char_literal44];

                     
                    /* ruleRef */
                    [self pushFollow:FOLLOW_conditional_in_ifstat751];
                    c2 = [self conditional];

                    [self popFollow];


                    [stream_conditional addElement:[c2 getTree]];
                    if (list_c2 == nil) list_c2 = [AMutableArray arrayWithCapacity:5];
                    [list_c2 addObject:[c2 getTree]];

                     
                    char_literal45=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_ifstat753];  
                        [stream_RPAREN addElement:char_literal45];

                     
                    RDELIM46=(CommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat755];  
                        [stream_RDELIM addElement:RDELIM46];

                     
                    /* ruleRef */
                    [self pushFollow:FOLLOW_template_in_ifstat759];
                    t2 = [self template];

                    [self popFollow];


                    [stream_template addElement:[t2 getTree]];
                    if (list_t2 == nil) list_t2 = [AMutableArray arrayWithCapacity:5];
                    [list_t2 addObject:[t2 getTree]];

                     
                    }
                    break;

                default :
                    goto loop15;
            }
        } while (YES);
        loop15: ;

         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:161:13: ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? // block
        NSInteger alt17=2;
        NSInteger LA17_0 = [input LA:1];

        if ( LA17_0==INDENT ) {
            NSInteger LA17_1 = [input LA:2];

            if ( LA17_1==LDELIM ) {
                NSInteger LA17_2 = [input LA:3];

                if ( LA17_2==ELSE ) {
                    alt17=1;
                }
            }
        }
        else if ( LA17_0==LDELIM ) {
            NSInteger LA17_2 = [input LA:2];

            if ( LA17_2==ELSE ) {
                alt17=1;
            }
        }
        switch (alt17) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:161:15: ( INDENT )? LDELIM 'else' RDELIM t3= template // alt
                {

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:161:15: ( INDENT )? // block
                NSInteger alt16=2;
                NSInteger LA16_0 = [input LA:1];

                if ( LA16_0==INDENT ) {
                    alt16=1;
                }
                switch (alt16) {
                    case 1 : ;
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:161:15: INDENT // alt
                        {

                        INDENT47=(CommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat778];  
                            [stream_INDENT addElement:INDENT47];

                         
                        }
                        break;

                }

                 
                LDELIM48=(CommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat781];  
                    [stream_LDELIM addElement:LDELIM48];

                 
                string_literal49=(CommonToken *)[self match:input TokenType:ELSE Follow:FOLLOW_ELSE_in_ifstat783];  
                    [stream_ELSE addElement:string_literal49];

                 
                RDELIM50=(CommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat785];  
                    [stream_RDELIM addElement:RDELIM50];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_template_in_ifstat789];
                t3 = [self template];

                [self popFollow];


                [stream_template addElement:[t3 getTree]];
                 
                }
                break;

        }

         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:162:13: ( INDENT )? // block
        NSInteger alt18=2;
        NSInteger LA18_0 = [input LA:1];

        if ( LA18_0==INDENT ) {
            alt18=1;
        }
        switch (alt18) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:162:13: INDENT // alt
                {

                INDENT51=(CommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat806];  
                    [stream_INDENT addElement:INDENT51];

                 
                }
                break;

        }

         
        endif=(CommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat812];  
            [stream_LDELIM addElement:endif];

         
        string_literal52=(CommonToken *)[self match:input TokenType:ENDIF Follow:FOLLOW_ENDIF_in_ifstat814];  
            [stream_ENDIF addElement:string_literal52];

         
        RDELIM53=(CommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat824];  
            [stream_RDELIM addElement:RDELIM53];

         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:165:9: ({...}? => NEWLINE )? // block
        NSInteger alt19=2;
        NSInteger LA19_0 = [input LA:1];

        if ( LA19_0==NEWLINE ) {
            NSInteger LA19_1 = [input LA:2];

            if ( (( ((CommonToken *)retval.start).line != [input LT:1].line )) ) {
                alt19=1;
            }
        }
        switch (alt19) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:165:10: {...}? => NEWLINE // alt
                {

                if ( !(( ((CommonToken *)retval.start).line != [input LT:1].line )) ) {
                    @throw [FailedPredicateException newException:@"ifstat" predicate:@" $ifstat.start.line != [input LT:1].line " stream:input];
                }
                 
                NEWLINE54=(CommonToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_ifstat847];  
                    [stream_NEWLINE addElement:NEWLINE54];

                 
                }
                break;

        }

         
        // AST REWRITE
        // elements: c2, t3, ELSE, c1, t2, ELSEIF, t3, i, ELSEIF, ELSE, t2, t1, c2, IF, c1, t1, IF
        // token labels: i
        // rule labels: t3, retval, t1, c1
        // token list labels: 
        // rule list labels: t2, c2
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleTokenStream *stream_i =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor description:@"token i" element:i];
        RewriteRuleSubtreeStream *stream_t3 =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token t3" element:t3!=nil?[t3 getTree]:nil];
        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];
        RewriteRuleSubtreeStream *stream_t1 =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token t1" element:t1!=nil?[t1 getTree]:nil];
        RewriteRuleSubtreeStream *stream_c1 =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token c1" element:c1!=nil?[c1 getTree]:nil];
        RewriteRuleSubtreeStream *stream_t2 =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token t2" elements:list_t2];
        RewriteRuleSubtreeStream *stream_c2 =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token c2" elements:list_c2];
        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 166:9: -> {indent!=nil}? ^( INDENTED_EXPR $i ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) )
        if (indent!=nil) {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:167:12: ^( INDENTED_EXPR $i ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) )
            {
                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INDENTED_EXPR Text:@"INDENTED_EXPR"] old:root_1];

                [treeAdaptor addChild:[stream_i nextNode] toTree:root_1];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:167:31: ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? )
                {
                    CommonTree *root_2 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                    root_2 = (CommonTree *)[treeAdaptor becomeRoot:[stream_IF nextNode] old:root_2];

                    [treeAdaptor addChild:[stream_c1 nextTree] toTree:root_2];

                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:167:43: ( $t1)?
                    if ( [stream_t1 hasNext] ) {
                    	[treeAdaptor addChild:[stream_t1 nextTree] toTree:root_2];

                    }
                    [stream_t1 reset];

                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:167:47: ( ^( 'elseif' $c2 $t2) )*
                    while ( [stream_c2 hasNext]||[stream_t2 hasNext]||[stream_ELSEIF hasNext] ) {
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:167:47: ^( 'elseif' $c2 $t2)
                        {
                            CommonTree *root_3 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                            root_3 = (CommonTree *)[treeAdaptor becomeRoot:[stream_ELSEIF nextNode] old:root_3];

                            [treeAdaptor addChild:[stream_c2 nextTree] toTree:root_3];

                            [treeAdaptor addChild:[stream_t2 nextTree] toTree:root_3];

                            [treeAdaptor addChild:root_3 toTree:root_2];
                        }

                    }
                    [stream_c2 reset];
                    [stream_t2 reset];
                    [stream_ELSEIF reset];

                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:167:68: ( ^( 'else' ( $t3)? ) )?
                    if ( [stream_ELSE hasNext]||[stream_t3 hasNext] ) {
                    	// /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:167:68: ^( 'else' ( $t3)? )
                    	{
                    	    CommonTree *root_3 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                    	    root_3 = (CommonTree *)[treeAdaptor becomeRoot:[stream_ELSE nextNode] old:root_3];

                    	    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:167:78: ( $t3)?
                    	    if ( [stream_t3 hasNext] ) {
                    	    	[treeAdaptor addChild:[stream_t3 nextTree] toTree:root_3];

                    	    }
                    	    [stream_t3 reset];

                    	    [treeAdaptor addChild:root_3 toTree:root_2];
                    	}

                    }
                    [stream_ELSE reset];
                    [stream_t3 reset];

                    [treeAdaptor addChild:root_2 toTree:root_1];
                }

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        else // 168:9: -> ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? )
        {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:168:31: ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? )
            {
                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[stream_IF nextNode] old:root_1];

                [treeAdaptor addChild:[stream_c1 nextTree] toTree:root_1];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:168:43: ( $t1)?
                if ( [stream_t1 hasNext] ) {
                	[treeAdaptor addChild:[stream_t1 nextTree] toTree:root_1];

                }
                [stream_t1 reset];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:168:47: ( ^( 'elseif' $c2 $t2) )*
                while ( [stream_c2 hasNext]||[stream_t2 hasNext]||[stream_ELSEIF hasNext] ) {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:168:47: ^( 'elseif' $c2 $t2)
                    {
                        CommonTree *root_2 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_2 = (CommonTree *)[treeAdaptor becomeRoot:[stream_ELSEIF nextNode] old:root_2];

                        [treeAdaptor addChild:[stream_c2 nextTree] toTree:root_2];

                        [treeAdaptor addChild:[stream_t2 nextTree] toTree:root_2];

                        [treeAdaptor addChild:root_2 toTree:root_1];
                    }

                }
                [stream_c2 reset];
                [stream_t2 reset];
                [stream_ELSEIF reset];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:168:68: ( ^( 'else' ( $t3)? ) )?
                if ( [stream_t3 hasNext]||[stream_ELSE hasNext] ) {
                	// /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:168:68: ^( 'else' ( $t3)? )
                	{
                	    CommonTree *root_2 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                	    root_2 = (CommonTree *)[treeAdaptor becomeRoot:[stream_ELSE nextNode] old:root_2];

                	    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:168:78: ( $t3)?
                	    if ( [stream_t3 hasNext] ) {
                	    	[treeAdaptor addChild:[stream_t3 nextTree] toTree:root_2];

                	    }
                	    [stream_t3 reset];

                	    [treeAdaptor addChild:root_2 toTree:root_1];
                	}

                }
                [stream_t3 reset];
                [stream_ELSE reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        list_c2 = nil;
        list_t2 = nil;
        [retval setStop:[input LT:-1]];


        stream_ENDIF = nil;
        stream_RDELIM = nil;
        stream_RPAREN = nil;
        stream_NEWLINE = nil;
        stream_LDELIM = nil;
        stream_INDENT = nil;
        stream_LPAREN = nil;
        stream_IF = nil;
        stream_ELSE = nil;
        stream_ELSEIF = nil;
        stream_template = nil;
        stream_conditional = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end ifstat */

/*
 * $ANTLR start conditional
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:171:1: conditional : andConditional ( '||' ^ andConditional )* ;
 */
- (STParser_conditional_return *) conditional
{
    /* ruleScopeSetUp */
    [conditional_stack push:[conditional_Scope newconditional_Scope]];
    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_conditional_return * retval = [STParser_conditional_return newSTParser_conditional_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *string_literal56 = nil;

        STParser_andConditional_return * andConditional55 = nil ;

        STParser_andConditional_return * andConditional57 = nil ;



        CommonTree *string_literal56_tree=nil;

        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:175:5: ( andConditional ( '||' ^ andConditional )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:175:7: andConditional ( '||' ^ andConditional )* // alt
        {
        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_andConditional_in_conditional991];
        andConditional55 = [self andConditional];

        [self popFollow];


        [treeAdaptor addChild:[andConditional55 getTree] toTree:root_0];
         

        do {
            NSInteger alt20=2;
            NSInteger LA20_0 = [input LA:1];
            if ( LA20_0==OR ) {
                alt20=1;
            }


            switch (alt20) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:175:24: '||' ^ andConditional // alt
                    {

                    string_literal56=(CommonToken *)[self match:input TokenType:OR Follow:FOLLOW_OR_in_conditional995]; 
                    string_literal56_tree = /* ASTParser createNodeFromToken */
                    (CommonTree *)[treeAdaptor create:string_literal56]
                    ;
                    root_0 = (CommonTree *)[treeAdaptor becomeRoot:string_literal56_tree old:root_0];

                     
                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_andConditional_in_conditional998];
                    andConditional57 = [self andConditional];

                    [self popFollow];


                    [treeAdaptor addChild:[andConditional57 getTree] toTree:root_0];
                     
                    }
                    break;

                default :
                    goto loop20;
            }
        } while (YES);
        loop20: ;

         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */
        [conditional_stack pop];
    }
    return retval;
}
/* $ANTLR end conditional */

/*
 * $ANTLR start andConditional
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:178:1: andConditional : notConditional ( '&&' ^ notConditional )* ;
 */
- (STParser_andConditional_return *) andConditional
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_andConditional_return * retval = [STParser_andConditional_return newSTParser_andConditional_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *string_literal59 = nil;

        STParser_notConditional_return * notConditional58 = nil ;

        STParser_notConditional_return * notConditional60 = nil ;



        CommonTree *string_literal59_tree=nil;

        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:178:16: ( notConditional ( '&&' ^ notConditional )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:178:18: notConditional ( '&&' ^ notConditional )* // alt
        {
        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_notConditional_in_andConditional1014];
        notConditional58 = [self notConditional];

        [self popFollow];


        [treeAdaptor addChild:[notConditional58 getTree] toTree:root_0];
         

        do {
            NSInteger alt21=2;
            NSInteger LA21_0 = [input LA:1];
            if ( LA21_0==AND ) {
                alt21=1;
            }


            switch (alt21) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:178:35: '&&' ^ notConditional // alt
                    {

                    string_literal59=(CommonToken *)[self match:input TokenType:AND Follow:FOLLOW_AND_in_andConditional1018]; 
                    string_literal59_tree = /* ASTParser createNodeFromToken */
                    (CommonTree *)[treeAdaptor create:string_literal59]
                    ;
                    root_0 = (CommonTree *)[treeAdaptor becomeRoot:string_literal59_tree old:root_0];

                     
                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_notConditional_in_andConditional1021];
                    notConditional60 = [self notConditional];

                    [self popFollow];


                    [treeAdaptor addChild:[notConditional60 getTree] toTree:root_0];
                     
                    }
                    break;

                default :
                    goto loop21;
            }
        } while (YES);
        loop21: ;

         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end andConditional */

/*
 * $ANTLR start notConditional
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:180:1: notConditional : ( '!' ^ notConditional | memberExpr );
 */
- (STParser_notConditional_return *) notConditional
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_notConditional_return * retval = [STParser_notConditional_return newSTParser_notConditional_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *char_literal61 = nil;

        STParser_notConditional_return * notConditional62 = nil ;

        STParser_memberExpr_return * memberExpr63 = nil ;



        CommonTree *char_literal61_tree=nil;

        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:181:5: ( '!' ^ notConditional | memberExpr ) //ruleblock
        NSInteger alt22=2;
        NSInteger LA22_0 = [input LA:1];

        if ( LA22_0==BANG ) {
            alt22=1;
        }
        else if ( LA22_0==ID||LA22_0==STRING||(LA22_0 >= T_FALSE && LA22_0 <= LBRACK)||LA22_0==SUPER||LA22_0==LCURLY||LA22_0==AT ) {
            alt22=2;
        }
        else if ( (LA22_0==LPAREN) && ((([conditional_stack count]>0)||([conditional_stack count]==0)))) {
            alt22=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:22 state:0 stream:input];
            nvae.c = LA22_0;
            @throw nvae;

        }
        switch (alt22) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:181:9: '!' ^ notConditional // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                char_literal61=(CommonToken *)[self match:input TokenType:BANG Follow:FOLLOW_BANG_in_notConditional1039]; 
                char_literal61_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[treeAdaptor create:char_literal61]
                ;
                root_0 = (CommonTree *)[treeAdaptor becomeRoot:char_literal61_tree old:root_0];

                 
                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_notConditional_in_notConditional1042];
                notConditional62 = [self notConditional];

                [self popFollow];


                [treeAdaptor addChild:[notConditional62 getTree] toTree:root_0];
                 
                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:182:9: memberExpr // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_memberExpr_in_notConditional1052];
                memberExpr63 = [self memberExpr];

                [self popFollow];


                [treeAdaptor addChild:[memberExpr63 getTree] toTree:root_0];
                 
                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end notConditional */

/*
 * $ANTLR start notConditionalExpr
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:185:1: notConditionalExpr : ( ID -> ID ) (p= '.' prop= ID -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr ) )* ;
 */
- (STParser_notConditionalExpr_return *) notConditionalExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_notConditionalExpr_return * retval = [STParser_notConditionalExpr_return newSTParser_notConditionalExpr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *p = nil;
        CommonToken *prop = nil;
        CommonToken *ID64 = nil;
        CommonToken *char_literal65 = nil;
        CommonToken *char_literal67 = nil;

        STParser_mapExpr_return * mapExpr66 = nil ;



        CommonTree *p_tree=nil;
        CommonTree *prop_tree=nil;
        CommonTree *ID64_tree=nil;
        CommonTree *char_literal65_tree=nil;
        CommonTree *char_literal67_tree=nil;
        RewriteRuleTokenStream *stream_RPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"];
        RewriteRuleTokenStream *stream_DOT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token DOT"];
        RewriteRuleTokenStream *stream_ID =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"];
        RewriteRuleTokenStream *stream_LPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"];
        RewriteRuleSubtreeStream *stream_mapExpr =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapExpr"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:186:5: ( ( ID -> ID ) (p= '.' prop= ID -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr ) )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:186:9: ( ID -> ID ) (p= '.' prop= ID -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr ) )* // alt
        {

        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:186:9: ( ID -> ID ) // blockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:186:10: ID // alt
        {

        ID64=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_notConditionalExpr1072];  
            [stream_ID addElement:ID64];

         
        // AST REWRITE
        // elements: ID
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 186:12: -> ID
        {
             // TODO: args: 
            [treeAdaptor addChild:[stream_ID nextNode] toTree:root_0];

        }


        retval.tree = root_0;


        }

         

        do {
            NSInteger alt23=3;
            NSInteger LA23_0 = [input LA:1];
            if ( LA23_0==DOT ) {
                NSInteger LA23_2 = [input LA:2];
                if ( LA23_2==ID ) {
                    alt23=1;
                }
                else if ( LA23_2==LPAREN ) {
                    alt23=2;
                }


            }


            switch (alt23) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:187:13: p= '.' prop= ID // alt
                    {

                    p=(CommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_notConditionalExpr1091];  
                        [stream_DOT addElement:p];

                     
                    prop=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_notConditionalExpr1095];  
                        [stream_ID addElement:prop];

                     
                    // AST REWRITE
                    // elements: prop, notConditionalExpr
                    // token labels: prop
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleTokenStream *stream_prop =
                        [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor description:@"token prop" element:prop];
                    RewriteRuleSubtreeStream *stream_retval =
                        [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                    root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                    // 187:49: -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop)
                    {
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:187:52: ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop)
                        {
                            CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:PROP FromToken:p Text:@"PROP"] old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                            [treeAdaptor addChild:[stream_prop nextNode] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:188:13: p= '.' '(' mapExpr ')' // alt
                    {

                    p=(CommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_notConditionalExpr1146];  
                        [stream_DOT addElement:p];

                     
                    char_literal65=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_notConditionalExpr1148];  
                        [stream_LPAREN addElement:char_literal65];

                     
                    /* ruleRef */
                    [self pushFollow:FOLLOW_mapExpr_in_notConditionalExpr1150];
                    mapExpr66 = [self mapExpr];

                    [self popFollow];


                    [stream_mapExpr addElement:[mapExpr66 getTree]];
                     
                    char_literal67=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_notConditionalExpr1152];  
                        [stream_RPAREN addElement:char_literal67];

                     
                    // AST REWRITE
                    // elements: mapExpr, notConditionalExpr
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleSubtreeStream *stream_retval =
                        [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                    root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                    // 188:49: -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr )
                    {
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:188:52: ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr )
                        {
                            CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:PROP_IND FromToken:p Text:@"PROP_IND"] old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                            [treeAdaptor addChild:[stream_mapExpr nextTree] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;

                default :
                    goto loop23;
            }
        } while (YES);
        loop23: ;

         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_RPAREN = nil;
        stream_DOT = nil;
        stream_ID = nil;
        stream_LPAREN = nil;
        stream_mapExpr = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end notConditionalExpr */

/*
 * $ANTLR start exprOptions
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:192:1: exprOptions : option ( ',' option )* -> ^( OPTIONS ( option )* ) ;
 */
- (STParser_exprOptions_return *) exprOptions
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_exprOptions_return * retval = [STParser_exprOptions_return newSTParser_exprOptions_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *char_literal69 = nil;

        STParser_option_return * option68 = nil ;

        STParser_option_return * option70 = nil ;



        CommonTree *char_literal69_tree=nil;
        RewriteRuleTokenStream *stream_COMMA =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"];
        RewriteRuleSubtreeStream *stream_option =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule option"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:192:13: ( option ( ',' option )* -> ^( OPTIONS ( option )* ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:192:15: option ( ',' option )* // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_option_in_exprOptions1202];
        option68 = [self option];

        [self popFollow];


        [stream_option addElement:[option68 getTree]];
         

        do {
            NSInteger alt24=2;
            NSInteger LA24_0 = [input LA:1];
            if ( LA24_0==COMMA ) {
                alt24=1;
            }


            switch (alt24) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:192:24: ',' option // alt
                    {

                    char_literal69=(CommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_exprOptions1206];  
                        [stream_COMMA addElement:char_literal69];

                     
                    /* ruleRef */
                    [self pushFollow:FOLLOW_option_in_exprOptions1208];
                    option70 = [self option];

                    [self popFollow];


                    [stream_option addElement:[option70 getTree]];
                     
                    }
                    break;

                default :
                    goto loop24;
            }
        } while (YES);
        loop24: ;

         
        // AST REWRITE
        // elements: option
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 192:38: -> ^( OPTIONS ( option )* )
        {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:192:41: ^( OPTIONS ( option )* )
            {
                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:OPTIONS Text:@"OPTIONS"] old:root_1];

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:192:51: ( option )*
                while ( [stream_option hasNext] ) {
                    [treeAdaptor addChild:[stream_option nextTree] toTree:root_1];

                }
                [stream_option reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_COMMA = nil;
        stream_option = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end exprOptions */

/*
 * $ANTLR start option
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:194:1: option : ID ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) ->| -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] ) ->) ;
 */
- (STParser_option_return *) option
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_option_return * retval = [STParser_option_return newSTParser_option_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;


        NSString *IDstr = [input LT:1].text;
        NSString *defVal = [[Compiler defaultOptionValues] get:IDstr];
        BOOL validOption = ([[Compiler getSupportedOptions] get:IDstr] != nil);

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *ID71 = nil;
        CommonToken *char_literal72 = nil;

        STParser_exprNoComma_return * exprNoComma73 = nil ;



        CommonTree *ID71_tree=nil;
        CommonTree *char_literal72_tree=nil;
        RewriteRuleTokenStream *stream_EQUALS =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token EQUALS"];
        RewriteRuleTokenStream *stream_ID =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"];
        RewriteRuleSubtreeStream *stream_exprNoComma =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule exprNoComma"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:200:5: ( ID ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) ->| -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] ) ->) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:200:9: ID ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) ->| -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] ) ->) // alt
        {

        ID71=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_option1240];  
            [stream_ID addElement:ID71];

         


                if ( !validOption ) {
                    [errMgr compileTimeError:NO_SUCH_OPTION templateToken:templateToken t:ID71 arg:(ID71!=nil?ID71.text:nil)];
                }
                

         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:206:9: ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) ->| -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] ) ->) // block
        NSInteger alt25=2;
        NSInteger LA25_0 = [input LA:1];

        if ( LA25_0==EQUALS ) {
            alt25=1;
        }
        else if ( LA25_0==COMMA||LA25_0==RDELIM ) {
            alt25=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:25 state:0 stream:input];
            nvae.c = LA25_0;
            @throw nvae;

        }
        switch (alt25) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:206:13: '=' exprNoComma // alt
                {

                char_literal72=(CommonToken *)[self match:input TokenType:EQUALS Follow:FOLLOW_EQUALS_in_option1264];  
                    [stream_EQUALS addElement:char_literal72];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_exprNoComma_in_option1266];
                exprNoComma73 = [self exprNoComma];

                [self popFollow];


                [stream_exprNoComma addElement:[exprNoComma73 getTree]];
                 
                // AST REWRITE
                // elements: exprNoComma, EQUALS, ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 206:49: -> {validOption}? ^( '=' ID exprNoComma )
                if (validOption) {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:206:67: ^( '=' ID exprNoComma )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[stream_EQUALS nextNode] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                        [treeAdaptor addChild:[stream_exprNoComma nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                else // 207:49: ->
                {
                    root_0 = nil;
                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:208:13:  // alt
                {



                            if ( defVal==nil ) {
                                [errMgr compileTimeError:NO_DEFAULT_VALUE templateToken:templateToken t:ID71  arg:ID71];
                            }
                            

                 
                // AST REWRITE
                // elements: ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 213:49: -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] )
                if (validOption&&defVal!=nil) {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:214:52: ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:EQUALS Text:@"EQUALS"]  old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                        [treeAdaptor addChild:[treeAdaptor createTree:STRING FromToken:ID71 Text:defVal] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                else // 215:49: ->
                {
                    root_0 = nil;
                }


                retval.tree = root_0;


                }
                break;

        }

         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_EQUALS = nil;
        stream_ID = nil;
        stream_exprNoComma = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end option */

/*
 * $ANTLR start exprNoComma
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:219:1: exprNoComma : memberExpr ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) ;
 */
- (STParser_exprNoComma_return *) exprNoComma
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_exprNoComma_return * retval = [STParser_exprNoComma_return newSTParser_exprNoComma_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *char_literal75 = nil;

        STParser_memberExpr_return * memberExpr74 = nil ;

        STParser_mapTemplateRef_return * mapTemplateRef76 = nil ;



        CommonTree *char_literal75_tree=nil;
        RewriteRuleTokenStream *stream_COLON =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COLON"];
        RewriteRuleSubtreeStream *stream_memberExpr =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule memberExpr"];
        RewriteRuleSubtreeStream *stream_mapTemplateRef =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapTemplateRef"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:220:5: ( memberExpr ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:220:9: memberExpr ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_memberExpr_in_exprNoComma1554];
        memberExpr74 = [self memberExpr];

        [self popFollow];


        [stream_memberExpr addElement:[memberExpr74 getTree]];
         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:221:9: ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) // block
        NSInteger alt26=2;
        NSInteger LA26_0 = [input LA:1];

        if ( LA26_0==COLON ) {
            alt26=1;
        }
        else if ( (LA26_0==RBRACK||LA26_0==RPAREN||LA26_0==COMMA||LA26_0==RDELIM) ) {
            alt26=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:26 state:0 stream:input];
            nvae.c = LA26_0;
            @throw nvae;

        }
        switch (alt26) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:221:11: ':' mapTemplateRef // alt
                {

                char_literal75=(CommonToken *)[self match:input TokenType:COLON Follow:FOLLOW_COLON_in_exprNoComma1566];  
                    [stream_COLON addElement:char_literal75];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_mapTemplateRef_in_exprNoComma1568];
                mapTemplateRef76 = [self mapTemplateRef];

                [self popFollow];


                [stream_mapTemplateRef addElement:[mapTemplateRef76 getTree]];
                 
                // AST REWRITE
                // elements: mapTemplateRef, memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 221:49: -> ^( MAP memberExpr mapTemplateRef )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:221:52: ^( MAP memberExpr mapTemplateRef )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:MAP Text:@"MAP"] old:root_1];

                        [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_1];

                        [treeAdaptor addChild:[stream_mapTemplateRef nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:222:49:  // alt
                {
                // AST REWRITE
                // elements: memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 222:49: -> memberExpr
                {
                    [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_0];

                }


                retval.tree = root_0;


                }
                break;

        }

         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_COLON = nil;
        stream_memberExpr = nil;
        stream_mapTemplateRef = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end exprNoComma */

/*
 * $ANTLR start expr
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:226:1: expr : mapExpr ;
 */
- (STParser_expr_return *) expr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_expr_return * retval = [STParser_expr_return newSTParser_expr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */


        STParser_mapExpr_return * mapExpr77 = nil ;




        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:226:6: ( mapExpr ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:226:8: mapExpr // alt
        {
        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_mapExpr_in_expr1672];
        mapExpr77 = [self mapExpr];

        [self popFollow];


        [treeAdaptor addChild:[mapExpr77 getTree] toTree:root_0];
         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end expr */

/*
 * $ANTLR start mapExpr
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:230:1: mapExpr : memberExpr ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) (col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* -> ^( MAP[$col] $mapExpr ( $x)+ ) )* ;
 */
- (STParser_mapExpr_return *) mapExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_mapExpr_return * retval = [STParser_mapExpr_return newSTParser_mapExpr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *c = nil;
        CommonToken *col = nil;
        CommonToken *char_literal81 = nil;
        AMutableArray *list_x = nil;
        STParser_memberExpr_return * memberExpr78 = nil ;

        STParser_memberExpr_return * memberExpr79 = nil ;

        STParser_mapTemplateRef_return * mapTemplateRef80 = nil ;

        ParserRuleReturnScope *x = nil;

        CommonTree *c_tree=nil;
        CommonTree *col_tree=nil;
        CommonTree *char_literal81_tree=nil;
        RewriteRuleTokenStream *stream_COLON =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COLON"];
        RewriteRuleTokenStream *stream_COMMA =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"];
        RewriteRuleSubtreeStream *stream_memberExpr =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule memberExpr"];
        RewriteRuleSubtreeStream *stream_mapTemplateRef =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapTemplateRef"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:231:5: ( memberExpr ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) (col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* -> ^( MAP[$col] $mapExpr ( $x)+ ) )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:231:9: memberExpr ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) (col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* -> ^( MAP[$col] $mapExpr ( $x)+ ) )* // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_memberExpr_in_mapExpr1689];
        memberExpr78 = [self memberExpr];

        [self popFollow];


        [stream_memberExpr addElement:[memberExpr78 getTree]];
         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:232:9: ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) // block
        NSInteger alt28=2;
        NSInteger LA28_0 = [input LA:1];

        if ( LA28_0==COMMA ) {
            alt28=1;
        }
        else if ( (LA28_0==RPAREN||LA28_0==SEMI||LA28_0==COLON||LA28_0==RDELIM) ) {
            alt28=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:28 state:0 stream:input];
            nvae.c = LA28_0;
            @throw nvae;

        }
        switch (alt28) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:232:11: (c= ',' memberExpr )+ col= ':' mapTemplateRef // alt
                {

                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:232:11: (c= ',' memberExpr )+ // positiveClosureBlock
                NSInteger cnt27 = 0;
                do {
                    NSInteger alt27 = 2;
                    NSInteger LA27_0 = [input LA:1];
                    if ( LA27_0==COMMA ) {
                        alt27=1;
                    }


                    switch (alt27) {
                        case 1 : ;
                            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:232:12: c= ',' memberExpr // alt
                            {

                            c=(CommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_mapExpr1704];  
                                [stream_COMMA addElement:c];

                             
                            /* ruleRef */
                            [self pushFollow:FOLLOW_memberExpr_in_mapExpr1706];
                            memberExpr79 = [self memberExpr];

                            [self popFollow];


                            [stream_memberExpr addElement:[memberExpr79 getTree]];
                             
                            }
                            break;

                        default :
                            if ( cnt27 >= 1 )
                                goto loop27;
                            EarlyExitException *eee =
                                [EarlyExitException newException:input decisionNumber:27];
                            @throw eee;
                    }
                    cnt27++;
                } while (YES);
                loop27: ;

                 
                col=(CommonToken *)[self match:input TokenType:COLON Follow:FOLLOW_COLON_in_mapExpr1712];  
                    [stream_COLON addElement:col];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_mapTemplateRef_in_mapExpr1714];
                mapTemplateRef80 = [self mapTemplateRef];

                [self popFollow];


                [stream_mapTemplateRef addElement:[mapTemplateRef80 getTree]];
                 
                // AST REWRITE
                // elements: mapTemplateRef, memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 233:49: -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:233:52: ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:ZIP FromToken:col Text:@"ZIP"] old:root_1];

                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:233:64: ^( ELEMENTS ( memberExpr )+ )
                        {
                            CommonTree *root_2 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                            root_2 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:ELEMENTS Text:@"ELEMENTS"] old:root_2];

                            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:233:75: ( memberExpr )+
                            {
                            if ( !([stream_memberExpr hasNext]) ) {
                                @throw [RewriteEarlyExitException newException];
                            }
                            while ( [stream_memberExpr hasNext] ) {
                                [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_2];

                            }
                            [stream_memberExpr reset];

                            }
                            [treeAdaptor addChild:root_2 toTree:root_1];
                        }

                        [treeAdaptor addChild:[stream_mapTemplateRef nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:234:49:  // alt
                {
                // AST REWRITE
                // elements: memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 234:49: -> memberExpr
                {
                    [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_0];

                }


                retval.tree = root_0;


                }
                break;

        }

         

        do {
            NSInteger alt30=2;
            NSInteger LA30_0 = [input LA:1];
            if ( LA30_0==COLON ) {
                alt30=1;
            }


            switch (alt30) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:236:13: col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* // alt
                    {


                    if (list_x != nil) [list_x removeAllObjects];

                     
                    col=(CommonToken *)[self match:input TokenType:COLON Follow:FOLLOW_COLON_in_mapExpr1871];  
                        [stream_COLON addElement:col];

                     
                    /* ruleRef */
                    [self pushFollow:FOLLOW_mapTemplateRef_in_mapExpr1875];
                    x = [self mapTemplateRef];

                    [self popFollow];


                    [stream_mapTemplateRef addElement:[x getTree]];
                    if (list_x == nil) list_x = [AMutableArray arrayWithCapacity:5];
                    [list_x addObject:[x getTree]];

                     

                    do {
                        NSInteger alt29=2;
                        NSInteger LA29_0 = [input LA:1];
                        if ( (LA29_0==COMMA) && ((c==nil))) {
                            alt29=1;
                        }


                        switch (alt29) {
                            case 1 : ;
                                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:237:40: {...}? => ',' x+= mapTemplateRef // alt
                                {

                                if ( !((c==nil)) ) {
                                    @throw [FailedPredicateException newException:@"mapExpr" predicate:@"$c==nil" stream:input];
                                }
                                 
                                char_literal81=(CommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_mapExpr1881];  
                                    [stream_COMMA addElement:char_literal81];

                                 
                                /* ruleRef */
                                [self pushFollow:FOLLOW_mapTemplateRef_in_mapExpr1885];
                                x = [self mapTemplateRef];

                                [self popFollow];


                                [stream_mapTemplateRef addElement:[x getTree]];
                                if (list_x == nil) list_x = [AMutableArray arrayWithCapacity:5];
                                [list_x addObject:[x getTree]];

                                 
                                }
                                break;

                            default :
                                goto loop29;
                        }
                    } while (YES);
                    loop29: ;

                     
                    // AST REWRITE
                    // elements: x, mapExpr
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: x
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleSubtreeStream *stream_retval =
                        [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil];
                    RewriteRuleSubtreeStream *stream_x =
                        [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token x" elements:list_x];
                    root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                    // 238:49: -> ^( MAP[$col] $mapExpr ( $x)+ )
                    {
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:238:52: ^( MAP[$col] $mapExpr ( $x)+ )
                        {
                            CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:MAP FromToken:col Text:@"MAP"] old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:238:74: ( $x)+
                            {
                            if ( !([stream_x hasNext]) ) {
                                @throw [RewriteEarlyExitException newException];
                            }
                            while ( [stream_x hasNext] ) {
                                [treeAdaptor addChild:[stream_x nextTree] toTree:root_1];

                            }
                            [stream_x reset];

                            }
                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;

                default :
                    goto loop30;
            }
        } while (YES);
        loop30: ;

         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        list_x = nil;
        [retval setStop:[input LT:-1]];


        stream_COLON = nil;
        stream_COMMA = nil;
        stream_memberExpr = nil;
        stream_mapTemplateRef = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end mapExpr */

/*
 * $ANTLR start mapTemplateRef
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:247:1: mapTemplateRef : ( ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | subtemplate |lp= '(' mapExpr rp= ')' '(' ( argExprList )? ')' -> ^( INCLUDE_IND mapExpr ( argExprList )? ) );
 */
- (STParser_mapTemplateRef_return *) mapTemplateRef
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_mapTemplateRef_return * retval = [STParser_mapTemplateRef_return newSTParser_mapTemplateRef_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *lp = nil;
        CommonToken *rp = nil;
        CommonToken *ID82 = nil;
        CommonToken *char_literal83 = nil;
        CommonToken *char_literal85 = nil;
        CommonToken *char_literal88 = nil;
        CommonToken *char_literal90 = nil;

        STParser_args_return * args84 = nil ;

        STParser_subtemplate_return * subtemplate86 = nil ;

        STParser_mapExpr_return * mapExpr87 = nil ;

        STParser_argExprList_return * argExprList89 = nil ;



        CommonTree *lp_tree=nil;
        CommonTree *rp_tree=nil;
        CommonTree *ID82_tree=nil;
        CommonTree *char_literal83_tree=nil;
        CommonTree *char_literal85_tree=nil;
        CommonTree *char_literal88_tree=nil;
        CommonTree *char_literal90_tree=nil;
        RewriteRuleTokenStream *stream_RPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"];
        RewriteRuleTokenStream *stream_ID =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"];
        RewriteRuleTokenStream *stream_LPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"];
        RewriteRuleSubtreeStream *stream_argExprList =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule argExprList"];
        RewriteRuleSubtreeStream *stream_args =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule args"];
        RewriteRuleSubtreeStream *stream_mapExpr =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapExpr"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:248:5: ( ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | subtemplate |lp= '(' mapExpr rp= ')' '(' ( argExprList )? ')' -> ^( INCLUDE_IND mapExpr ( argExprList )? ) ) //ruleblock
        NSInteger alt32=3;
        unichar charLA32 = [input LA:1];
        switch (charLA32) {
            case ID: ;
                {
                alt32=1;
                }
                break;
            case LCURLY: ;
                {
                alt32=2;
                }
                break;
            case LPAREN: ;
                {
                alt32=3;
                }
                break;

        default: ;
            NoViableAltException *nvae = [NoViableAltException newException:32 state:0 stream:input];
            nvae.c = charLA32;
            @throw nvae;

        }

        switch (alt32) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:248:9: ID '(' args ')' // alt
                {

                ID82=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_mapTemplateRef1982];  
                    [stream_ID addElement:ID82];

                 
                char_literal83=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_mapTemplateRef1984];  
                    [stream_LPAREN addElement:char_literal83];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_args_in_mapTemplateRef1986];
                args84 = [self args];

                [self popFollow];


                [stream_args addElement:[args84 getTree]];
                 
                char_literal85=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_mapTemplateRef1988];  
                    [stream_RPAREN addElement:char_literal85];

                 
                // AST REWRITE
                // elements: ID, args
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 248:49: -> ^( INCLUDE ID ( args )? )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:248:52: ^( INCLUDE ID ( args )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INCLUDE Text:@"INCLUDE"] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:248:65: ( args )?
                        if ( [stream_args hasNext] ) {
                        	[treeAdaptor addChild:[stream_args nextTree] toTree:root_1];

                        }
                        [stream_args reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:249:9: subtemplate // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_subtemplate_in_mapTemplateRef2033];
                subtemplate86 = [self subtemplate];

                [self popFollow];


                [treeAdaptor addChild:[subtemplate86 getTree] toTree:root_0];
                 
                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:250:9: lp= '(' mapExpr rp= ')' '(' ( argExprList )? ')' // alt
                {

                lp=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_mapTemplateRef2045];  
                    [stream_LPAREN addElement:lp];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_mapExpr_in_mapTemplateRef2047];
                mapExpr87 = [self mapExpr];

                [self popFollow];


                [stream_mapExpr addElement:[mapExpr87 getTree]];
                 
                rp=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_mapTemplateRef2051];  
                    [stream_RPAREN addElement:rp];

                 
                char_literal88=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_mapTemplateRef2053];  
                    [stream_LPAREN addElement:char_literal88];

                 
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:250:35: ( argExprList )? // block
                NSInteger alt31=2;
                NSInteger LA31_0 = [input LA:1];

                if ( LA31_0==ID||LA31_0==STRING||(LA31_0 >= T_FALSE && LA31_0 <= LBRACK)||LA31_0==SUPER||LA31_0==LCURLY||LA31_0==AT ) {
                    alt31=1;
                }
                else if ( (LA31_0==LPAREN) && ((([conditional_stack count]>0)||([conditional_stack count]==0)))) {
                    alt31=1;
                }
                switch (alt31) {
                    case 1 : ;
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:250:35: argExprList // alt
                        {

                        /* ruleRef */
                        [self pushFollow:FOLLOW_argExprList_in_mapTemplateRef2055];
                        argExprList89 = [self argExprList];

                        [self popFollow];


                        [stream_argExprList addElement:[argExprList89 getTree]];
                         
                        }
                        break;

                }

                 
                char_literal90=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_mapTemplateRef2058];  
                    [stream_RPAREN addElement:char_literal90];

                 
                // AST REWRITE
                // elements: argExprList, mapExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 250:52: -> ^( INCLUDE_IND mapExpr ( argExprList )? )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:250:55: ^( INCLUDE_IND mapExpr ( argExprList )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INCLUDE_IND Text:@"INCLUDE_IND"] old:root_1];

                        [treeAdaptor addChild:[stream_mapExpr nextTree] toTree:root_1];

                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:250:77: ( argExprList )?
                        if ( [stream_argExprList hasNext] ) {
                        	[treeAdaptor addChild:[stream_argExprList nextTree] toTree:root_1];

                        }
                        [stream_argExprList reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_RPAREN = nil;
        stream_ID = nil;
        stream_LPAREN = nil;
        stream_argExprList = nil;
        stream_args = nil;
        stream_mapExpr = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end mapTemplateRef */

/*
 * $ANTLR start memberExpr
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:253:1: memberExpr : ( includeExpr -> includeExpr ) (p= '.' ID -> ^( PROP[$p,@\"PROP\"] $memberExpr ID ) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr ) )* ;
 */
- (STParser_memberExpr_return *) memberExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_memberExpr_return * retval = [STParser_memberExpr_return newSTParser_memberExpr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *p = nil;
        CommonToken *ID92 = nil;
        CommonToken *char_literal93 = nil;
        CommonToken *char_literal95 = nil;

        STParser_includeExpr_return * includeExpr91 = nil ;

        STParser_mapExpr_return * mapExpr94 = nil ;



        CommonTree *p_tree=nil;
        CommonTree *ID92_tree=nil;
        CommonTree *char_literal93_tree=nil;
        CommonTree *char_literal95_tree=nil;
        RewriteRuleTokenStream *stream_RPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"];
        RewriteRuleTokenStream *stream_DOT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token DOT"];
        RewriteRuleTokenStream *stream_ID =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"];
        RewriteRuleTokenStream *stream_LPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"];
        RewriteRuleSubtreeStream *stream_includeExpr =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule includeExpr"];
        RewriteRuleSubtreeStream *stream_mapExpr =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapExpr"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:254:5: ( ( includeExpr -> includeExpr ) (p= '.' ID -> ^( PROP[$p,@\"PROP\"] $memberExpr ID ) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr ) )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:254:9: ( includeExpr -> includeExpr ) (p= '.' ID -> ^( PROP[$p,@\"PROP\"] $memberExpr ID ) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr ) )* // alt
        {

        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:254:9: ( includeExpr -> includeExpr ) // blockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:254:10: includeExpr // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_includeExpr_in_memberExpr2089];
        includeExpr91 = [self includeExpr];

        [self popFollow];


        [stream_includeExpr addElement:[includeExpr91 getTree]];
         
        // AST REWRITE
        // elements: includeExpr
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 254:21: -> includeExpr
        {
            [treeAdaptor addChild:[stream_includeExpr nextTree] toTree:root_0];

        }


        retval.tree = root_0;


        }

         

        do {
            NSInteger alt33=3;
            NSInteger LA33_0 = [input LA:1];
            if ( LA33_0==DOT ) {
                NSInteger LA33_2 = [input LA:2];
                if ( LA33_2==ID ) {
                    alt33=1;
                }
                else if ( LA33_2==LPAREN ) {
                    alt33=2;
                }


            }


            switch (alt33) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:255:13: p= '.' ID // alt
                    {

                    p=(CommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_memberExpr2108];  
                        [stream_DOT addElement:p];

                     
                    ID92=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_memberExpr2110];  
                        [stream_ID addElement:ID92];

                     
                    // AST REWRITE
                    // elements: ID, memberExpr
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleSubtreeStream *stream_retval =
                        [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                    root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                    // 255:49: -> ^( PROP[$p,@\"PROP\"] $memberExpr ID )
                    {
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:255:52: ^( PROP[$p,@\"PROP\"] $memberExpr ID )
                        {
                            CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:PROP FromToken:p Text:@"PROP"] old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                             // TODO: args: 
                            [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:256:13: p= '.' '(' mapExpr ')' // alt
                    {

                    p=(CommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_memberExpr2165];  
                        [stream_DOT addElement:p];

                     
                    char_literal93=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_memberExpr2167];  
                        [stream_LPAREN addElement:char_literal93];

                     
                    /* ruleRef */
                    [self pushFollow:FOLLOW_mapExpr_in_memberExpr2169];
                    mapExpr94 = [self mapExpr];

                    [self popFollow];


                    [stream_mapExpr addElement:[mapExpr94 getTree]];
                     
                    char_literal95=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_memberExpr2171];  
                        [stream_RPAREN addElement:char_literal95];

                     
                    // AST REWRITE
                    // elements: memberExpr, mapExpr
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleSubtreeStream *stream_retval =
                        [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                    root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                    // 256:49: -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr )
                    {
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:256:52: ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr )
                        {
                            CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:PROP_IND FromToken:p Text:@"PROP_IND"] old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                            [treeAdaptor addChild:[stream_mapExpr nextTree] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;

                default :
                    goto loop33;
            }
        } while (YES);
        loop33: ;

         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_RPAREN = nil;
        stream_DOT = nil;
        stream_ID = nil;
        stream_LPAREN = nil;
        stream_includeExpr = nil;
        stream_mapExpr = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end memberExpr */

/*
 * $ANTLR start includeExpr
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:260:1: includeExpr options {k=2; } : ({...}? ID '(' ( expr )? ')' -> ^( EXEC_FUNC ID ( expr )? ) | 'super' '.' ID '(' args ')' -> ^( INCLUDE_SUPER ID ( args )? ) | ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | '@' 'super' '.' ID '(' rp= ')' -> ^( INCLUDE_SUPER_REGION ID ) | '@' ID '(' rp= ')' -> ^( INCLUDE_REGION ID ) | primary );
 */
- (STParser_includeExpr_return *) includeExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_includeExpr_return * retval = [STParser_includeExpr_return newSTParser_includeExpr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *rp = nil;
        CommonToken *ID96 = nil;
        CommonToken *char_literal97 = nil;
        CommonToken *char_literal99 = nil;
        CommonToken *string_literal100 = nil;
        CommonToken *char_literal101 = nil;
        CommonToken *ID102 = nil;
        CommonToken *char_literal103 = nil;
        CommonToken *char_literal105 = nil;
        CommonToken *ID106 = nil;
        CommonToken *char_literal107 = nil;
        CommonToken *char_literal109 = nil;
        CommonToken *char_literal110 = nil;
        CommonToken *string_literal111 = nil;
        CommonToken *char_literal112 = nil;
        CommonToken *ID113 = nil;
        CommonToken *char_literal114 = nil;
        CommonToken *char_literal115 = nil;
        CommonToken *ID116 = nil;
        CommonToken *char_literal117 = nil;

        STParser_expr_return * expr98 = nil ;

        STParser_args_return * args104 = nil ;

        STParser_args_return * args108 = nil ;

        STParser_primary_return * primary118 = nil ;



        CommonTree *rp_tree=nil;
        CommonTree *ID96_tree=nil;
        CommonTree *char_literal97_tree=nil;
        CommonTree *char_literal99_tree=nil;
        CommonTree *string_literal100_tree=nil;
        CommonTree *char_literal101_tree=nil;
        CommonTree *ID102_tree=nil;
        CommonTree *char_literal103_tree=nil;
        CommonTree *char_literal105_tree=nil;
        CommonTree *ID106_tree=nil;
        CommonTree *char_literal107_tree=nil;
        CommonTree *char_literal109_tree=nil;
        CommonTree *char_literal110_tree=nil;
        CommonTree *string_literal111_tree=nil;
        CommonTree *char_literal112_tree=nil;
        CommonTree *ID113_tree=nil;
        CommonTree *char_literal114_tree=nil;
        CommonTree *char_literal115_tree=nil;
        CommonTree *ID116_tree=nil;
        CommonTree *char_literal117_tree=nil;
        RewriteRuleTokenStream *stream_AT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token AT"];
        RewriteRuleTokenStream *stream_RPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"];
        RewriteRuleTokenStream *stream_SUPER =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token SUPER"];
        RewriteRuleTokenStream *stream_DOT =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token DOT"];
        RewriteRuleTokenStream *stream_ID =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"];
        RewriteRuleTokenStream *stream_LPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"];
        RewriteRuleSubtreeStream *stream_args =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule args"];
        RewriteRuleSubtreeStream *stream_expr =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:262:5: ({...}? ID '(' ( expr )? ')' -> ^( EXEC_FUNC ID ( expr )? ) | 'super' '.' ID '(' args ')' -> ^( INCLUDE_SUPER ID ( args )? ) | ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | '@' 'super' '.' ID '(' rp= ')' -> ^( INCLUDE_SUPER_REGION ID ) | '@' ID '(' rp= ')' -> ^( INCLUDE_REGION ID ) | primary ) //ruleblock
        NSInteger alt35=6;
        NSInteger LA35_0 = [input LA:1];

        if ( LA35_0==ID ) {
            NSInteger LA35_1 = [input LA:2];

            if ( LA35_1==LPAREN ) {
                NSInteger LA35_10 = [input LA:3];

                if ( (([[Compiler funcs] getInstr:[input LT:1].text])) ) {
                    alt35=1;
                }
                else if ( (YES) ) {
                    alt35=3;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:35 state:10 stream:input];
                    nvae.c = LA35_10;
                    @throw nvae;

                }
            }
            else if ( (LA35_1==RBRACK||LA35_1==RPAREN||LA35_1==SEMI||(LA35_1 >= COLON && LA35_1 <= DOT)||LA35_1==RDELIM||(LA35_1 >= OR && LA35_1 <= AND)) ) {
                alt35=6;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:35 state:1 stream:input];
                CommonToken *aToken = [input LT:2];
                if (LA35_1 == EQUALS) {
                    nvae.c = '=';
                    nvae.token = aToken;
                }
                else {
                    nvae.c = LA35_1;
                    nvae.token = aToken;
                }
                @throw nvae;

            }
        }
        else if ( LA35_0==SUPER ) {
            alt35=2;
        }
        else if ( LA35_0==AT ) {
            NSInteger LA35_3 = [input LA:2];

            if ( LA35_3==SUPER ) {
                alt35=4;
            }
            else if ( LA35_3==ID ) {
                alt35=5;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:35 state:3 stream:input];
                nvae.c = LA35_3;
                @throw nvae;

            }
        }
        else if ( LA35_0==STRING||(LA35_0 >= T_FALSE && LA35_0 <= LBRACK)||LA35_0==LCURLY ) {
            alt35=6;
        }
        else if ( (LA35_0==LPAREN) && ((([conditional_stack count]>0)||([conditional_stack count]==0)))) {
            alt35=6;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:35 state:0 stream:input];
            nvae.c = LA35_0;
            @throw nvae;

        }
        switch (alt35) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:262:9: {...}? ID '(' ( expr )? ')' // alt
                {

                if ( !(([[Compiler funcs] getInstr:[input LT:1].text])) ) {
                    @throw [FailedPredicateException newException:@"includeExpr" predicate:@"[[Compiler funcs] getInstr:[input LT:1].text]" stream:input];
                }
                 
                ID96=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2246];  
                    [stream_ID addElement:ID96];

                 
                char_literal97=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2248];  
                    [stream_LPAREN addElement:char_literal97];

                 
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:263:16: ( expr )? // block
                NSInteger alt34=2;
                NSInteger LA34_0 = [input LA:1];

                if ( LA34_0==ID||LA34_0==STRING||(LA34_0 >= T_FALSE && LA34_0 <= LBRACK)||LA34_0==SUPER||LA34_0==LCURLY||LA34_0==AT ) {
                    alt34=1;
                }
                else if ( (LA34_0==LPAREN) && ((([conditional_stack count]>0)||([conditional_stack count]==0)))) {
                    alt34=1;
                }
                switch (alt34) {
                    case 1 : ;
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:263:16: expr // alt
                        {

                        /* ruleRef */
                        [self pushFollow:FOLLOW_expr_in_includeExpr2250];
                        expr98 = [self expr];

                        [self popFollow];


                        [stream_expr addElement:[expr98 getTree]];
                         
                        }
                        break;

                }

                 
                char_literal99=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2253];  
                    [stream_RPAREN addElement:char_literal99];

                 
                // AST REWRITE
                // elements: expr, ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 263:49: -> ^( EXEC_FUNC ID ( expr )? )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:263:52: ^( EXEC_FUNC ID ( expr )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:EXEC_FUNC Text:@"EXEC_FUNC"] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:263:67: ( expr )?
                        if ( [stream_expr hasNext] ) {
                        	[treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                        }
                        [stream_expr reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:264:9: 'super' '.' ID '(' args ')' // alt
                {

                string_literal100=(CommonToken *)[self match:input TokenType:SUPER Follow:FOLLOW_SUPER_in_includeExpr2297];  
                    [stream_SUPER addElement:string_literal100];

                 
                char_literal101=(CommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_includeExpr2299];  
                    [stream_DOT addElement:char_literal101];

                 
                ID102=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2301];  
                    [stream_ID addElement:ID102];

                 
                char_literal103=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2303];  
                    [stream_LPAREN addElement:char_literal103];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_args_in_includeExpr2305];
                args104 = [self args];

                [self popFollow];


                [stream_args addElement:[args104 getTree]];
                 
                char_literal105=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2307];  
                    [stream_RPAREN addElement:char_literal105];

                 
                // AST REWRITE
                // elements: ID, args
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 264:49: -> ^( INCLUDE_SUPER ID ( args )? )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:264:52: ^( INCLUDE_SUPER ID ( args )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INCLUDE_SUPER Text:@"INCLUDE_SUPER"] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:264:71: ( args )?
                        if ( [stream_args hasNext] ) {
                        	[treeAdaptor addChild:[stream_args nextTree] toTree:root_1];

                        }
                        [stream_args reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:265:9: ID '(' args ')' // alt
                {

                ID106=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2340];  
                    [stream_ID addElement:ID106];

                 
                char_literal107=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2342];  
                    [stream_LPAREN addElement:char_literal107];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_args_in_includeExpr2344];
                args108 = [self args];

                [self popFollow];


                [stream_args addElement:[args108 getTree]];
                 
                char_literal109=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2346];  
                    [stream_RPAREN addElement:char_literal109];

                 
                // AST REWRITE
                // elements: args, ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 265:49: -> ^( INCLUDE ID ( args )? )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:265:52: ^( INCLUDE ID ( args )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INCLUDE Text:@"INCLUDE"] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:265:65: ( args )?
                        if ( [stream_args hasNext] ) {
                        	[treeAdaptor addChild:[stream_args nextTree] toTree:root_1];

                        }
                        [stream_args reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:266:9: '@' 'super' '.' ID '(' rp= ')' // alt
                {

                char_literal110=(CommonToken *)[self match:input TokenType:AT Follow:FOLLOW_AT_in_includeExpr2391];  
                    [stream_AT addElement:char_literal110];

                 
                string_literal111=(CommonToken *)[self match:input TokenType:SUPER Follow:FOLLOW_SUPER_in_includeExpr2393];  
                    [stream_SUPER addElement:string_literal111];

                 
                char_literal112=(CommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_includeExpr2395];  
                    [stream_DOT addElement:char_literal112];

                 
                ID113=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2397];  
                    [stream_ID addElement:ID113];

                 
                char_literal114=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2399];  
                    [stream_LPAREN addElement:char_literal114];

                 
                rp=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2403];  
                    [stream_RPAREN addElement:rp];

                 
                // AST REWRITE
                // elements: ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 266:49: -> ^( INCLUDE_SUPER_REGION ID )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:266:52: ^( INCLUDE_SUPER_REGION ID )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INCLUDE_SUPER_REGION Text:@"INCLUDE_SUPER_REGION"] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 5 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:267:9: '@' ID '(' rp= ')' // alt
                {

                char_literal115=(CommonToken *)[self match:input TokenType:AT Follow:FOLLOW_AT_in_includeExpr2431];  
                    [stream_AT addElement:char_literal115];

                 
                ID116=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2433];  
                    [stream_ID addElement:ID116];

                 
                char_literal117=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2435];  
                    [stream_LPAREN addElement:char_literal117];

                 
                rp=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2439];  
                    [stream_RPAREN addElement:rp];

                 
                // AST REWRITE
                // elements: ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 267:49: -> ^( INCLUDE_REGION ID )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:267:52: ^( INCLUDE_REGION ID )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INCLUDE_REGION Text:@"INCLUDE_REGION"] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 6 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:268:9: primary // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_primary_in_includeExpr2479];
                primary118 = [self primary];

                [self popFollow];


                [treeAdaptor addChild:[primary118 getTree] toTree:root_0];
                 
                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_AT = nil;
        stream_RPAREN = nil;
        stream_SUPER = nil;
        stream_DOT = nil;
        stream_ID = nil;
        stream_LPAREN = nil;
        stream_args = nil;
        stream_expr = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end includeExpr */

/*
 * $ANTLR start primary
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:271:1: primary : ( ID | STRING | T_TRUE | T_FALSE | subtemplate | list |{...}? => '(' ! conditional ')' !|{...}? =>lp= '(' expr ')' ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) );
 */
- (STParser_primary_return *) primary
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_primary_return * retval = [STParser_primary_return newSTParser_primary_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *lp = nil;
        CommonToken *ID119 = nil;
        CommonToken *STRING120 = nil;
        CommonToken *T_TRUE121 = nil;
        CommonToken *T_FALSE122 = nil;
        CommonToken *char_literal125 = nil;
        CommonToken *char_literal127 = nil;
        CommonToken *char_literal129 = nil;
        CommonToken *char_literal130 = nil;
        CommonToken *char_literal132 = nil;

        STParser_subtemplate_return * subtemplate123 = nil ;

        STParser_list_return * list124 = nil ;

        STParser_conditional_return * conditional126 = nil ;

        STParser_expr_return * expr128 = nil ;

        STParser_argExprList_return * argExprList131 = nil ;



        CommonTree *lp_tree=nil;
        CommonTree *ID119_tree=nil;
        CommonTree *STRING120_tree=nil;
        CommonTree *T_TRUE121_tree=nil;
        CommonTree *T_FALSE122_tree=nil;
        CommonTree *char_literal125_tree=nil;
        CommonTree *char_literal127_tree=nil;
        CommonTree *char_literal129_tree=nil;
        CommonTree *char_literal130_tree=nil;
        CommonTree *char_literal132_tree=nil;
        RewriteRuleTokenStream *stream_RPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"];
        RewriteRuleTokenStream *stream_LPAREN =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"];
        RewriteRuleSubtreeStream *stream_argExprList =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule argExprList"];
        RewriteRuleSubtreeStream *stream_expr =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:272:5: ( ID | STRING | T_TRUE | T_FALSE | subtemplate | list |{...}? => '(' ! conditional ')' !|{...}? =>lp= '(' expr ')' ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) ) //ruleblock
        NSInteger alt38=8;
        NSInteger LA38_0 = [input LA:1];

        if ( LA38_0==ID ) {
            alt38=1;
        }
        else if ( LA38_0==STRING ) {
            alt38=2;
        }
        else if ( LA38_0==T_TRUE ) {
            alt38=3;
        }
        else if ( LA38_0==T_FALSE ) {
            alt38=4;
        }
        else if ( LA38_0==LCURLY ) {
            alt38=5;
        }
        else if ( LA38_0==LBRACK ) {
            alt38=6;
        }
        else if ( (LA38_0==LPAREN) && ((([conditional_stack count]>0)||([conditional_stack count]==0)))) {
            NSInteger LA38_7 = [input LA:2];

            if ( (([conditional_stack count]>0)) ) {
                alt38=7;
            }
            else if ( (([conditional_stack count]==0)) ) {
                alt38=8;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:38 state:7 stream:input];
                nvae.c = LA38_7;
                @throw nvae;

            }
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:38 state:0 stream:input];
            nvae.c = LA38_0;
            @throw nvae;

        }
        switch (alt38) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:272:9: ID // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser tokenRef */
                ID119=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_primary2498]; 
                ID119_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[treeAdaptor create:ID119]
                ;
                [treeAdaptor addChild:ID119_tree  toTree:root_0];

                 
                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:273:9: STRING // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser tokenRef */
                STRING120=(CommonToken *)[self match:input TokenType:STRING Follow:FOLLOW_STRING_in_primary2508]; 
                STRING120_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[treeAdaptor create:STRING120]
                ;
                [treeAdaptor addChild:STRING120_tree  toTree:root_0];

                 
                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:274:9: T_TRUE // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser tokenRef */
                T_TRUE121=(CommonToken *)[self match:input TokenType:T_TRUE Follow:FOLLOW_T_TRUE_in_primary2518]; 
                T_TRUE121_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[treeAdaptor create:T_TRUE121]
                ;
                [treeAdaptor addChild:T_TRUE121_tree  toTree:root_0];

                 
                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:275:9: T_FALSE // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser tokenRef */
                T_FALSE122=(CommonToken *)[self match:input TokenType:T_FALSE Follow:FOLLOW_T_FALSE_in_primary2528]; 
                T_FALSE122_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[treeAdaptor create:T_FALSE122]
                ;
                [treeAdaptor addChild:T_FALSE122_tree  toTree:root_0];

                 
                }
                break;
            case 5 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:276:9: subtemplate // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_subtemplate_in_primary2538];
                subtemplate123 = [self subtemplate];

                [self popFollow];


                [treeAdaptor addChild:[subtemplate123 getTree] toTree:root_0];
                 
                }
                break;
            case 6 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:277:9: list // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_list_in_primary2548];
                list124 = [self list];

                [self popFollow];


                [treeAdaptor addChild:[list124 getTree] toTree:root_0];
                 
                }
                break;
            case 7 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:278:9: {...}? => '(' ! conditional ')' ! // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                if ( !(([conditional_stack count]>0)) ) {
                    @throw [FailedPredicateException newException:@"primary" predicate:@"[$conditional count]>0" stream:input];
                }
                 
                char_literal125=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_primary2562]; 
                 
                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_conditional_in_primary2565];
                conditional126 = [self conditional];

                [self popFollow];


                [treeAdaptor addChild:[conditional126 getTree] toTree:root_0];
                 
                char_literal127=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_primary2567]; 
                 
                }
                break;
            case 8 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:279:9: {...}? =>lp= '(' expr ')' ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) // alt
                {

                if ( !(([conditional_stack count]==0)) ) {
                    @throw [FailedPredicateException newException:@"primary" predicate:@"[$conditional count]==0" stream:input];
                }
                 
                lp=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_primary2583];  
                    [stream_LPAREN addElement:lp];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_expr_in_primary2585];
                expr128 = [self expr];

                [self popFollow];


                [stream_expr addElement:[expr128 getTree]];
                 
                char_literal129=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_primary2587];  
                    [stream_RPAREN addElement:char_literal129];

                 
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:280:9: ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) // block
                NSInteger alt37=2;
                NSInteger LA37_0 = [input LA:1];

                if ( LA37_0==LPAREN ) {
                    alt37=1;
                }
                else if ( (LA37_0==RBRACK||LA37_0==RPAREN||LA37_0==SEMI||(LA37_0 >= COLON && LA37_0 <= DOT)||LA37_0==RDELIM||(LA37_0 >= OR && LA37_0 <= AND)) ) {
                    alt37=2;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:37 state:0 stream:input];
                    nvae.c = LA37_0;
                    @throw nvae;

                }
                switch (alt37) {
                    case 1 : ;
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:280:13: '(' ( argExprList )? ')' // alt
                        {

                        char_literal130=(CommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_primary2601];  
                            [stream_LPAREN addElement:char_literal130];

                         
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:280:17: ( argExprList )? // block
                        NSInteger alt36=2;
                        NSInteger LA36_0 = [input LA:1];

                        if ( LA36_0==ID||LA36_0==STRING||(LA36_0 >= T_FALSE && LA36_0 <= LBRACK)||LA36_0==SUPER||LA36_0==LCURLY||LA36_0==AT ) {
                            alt36=1;
                        }
                        else if ( (LA36_0==LPAREN) && ((([conditional_stack count]>0)||([conditional_stack count]==0)))) {
                            alt36=1;
                        }
                        switch (alt36) {
                            case 1 : ;
                                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:280:17: argExprList // alt
                                {

                                /* ruleRef */
                                [self pushFollow:FOLLOW_argExprList_in_primary2603];
                                argExprList131 = [self argExprList];

                                [self popFollow];


                                [stream_argExprList addElement:[argExprList131 getTree]];
                                 
                                }
                                break;

                        }

                         
                        char_literal132=(CommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_primary2606];  
                            [stream_RPAREN addElement:char_literal132];

                         
                        // AST REWRITE
                        // elements: expr, argExprList
                        // token labels: 
                        // rule labels: retval
                        // token list labels: 
                        // rule list labels: 
                        // wildcard labels: 
                        retval.tree = root_0;

                        RewriteRuleSubtreeStream *stream_retval =
                            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                        // 280:49: -> ^( INCLUDE_IND[$lp] expr ( argExprList )? )
                        {
                            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:280:52: ^( INCLUDE_IND[$lp] expr ( argExprList )? )
                            {
                                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:INCLUDE_IND FromToken:lp Text:@"INCLUDE_IND"] old:root_1];

                                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:280:76: ( argExprList )?
                                if ( [stream_argExprList hasNext] ) {
                                	[treeAdaptor addChild:[stream_argExprList nextTree] toTree:root_1];

                                }
                                [stream_argExprList reset];

                                [treeAdaptor addChild:root_1 toTree:root_0];
                            }

                        }


                        retval.tree = root_0;


                        }
                        break;
                    case 2 : ;
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:281:49:  // alt
                        {
                        // AST REWRITE
                        // elements: expr
                        // token labels: 
                        // rule labels: retval
                        // token list labels: 
                        // rule list labels: 
                        // wildcard labels: 
                        retval.tree = root_0;

                        RewriteRuleSubtreeStream *stream_retval =
                            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                        // 281:49: -> ^( TO_STR[$lp] expr )
                        {
                            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:281:52: ^( TO_STR[$lp] expr )
                            {
                                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:TO_STR FromToken:lp Text:@"TO_STR"] old:root_1];

                                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                                [treeAdaptor addChild:root_1 toTree:root_0];
                            }

                        }


                        retval.tree = root_0;


                        }
                        break;

                }

                 
                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_RPAREN = nil;
        stream_LPAREN = nil;
        stream_argExprList = nil;
        stream_expr = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end primary */

/*
 * $ANTLR start args
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:285:1: args : ( argExprList | namedArg ( ',' namedArg )* ( ',' '...' )? -> ( namedArg )+ ( '...' )? | '...' |);
 */
- (STParser_args_return *) args
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_args_return * retval = [STParser_args_return newSTParser_args_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *char_literal135 = nil;
        CommonToken *char_literal137 = nil;
        CommonToken *string_literal138 = nil;
        CommonToken *string_literal139 = nil;

        STParser_argExprList_return * argExprList133 = nil ;

        STParser_namedArg_return * namedArg134 = nil ;

        STParser_namedArg_return * namedArg136 = nil ;



        CommonTree *char_literal135_tree=nil;
        CommonTree *char_literal137_tree=nil;
        CommonTree *string_literal138_tree=nil;
        CommonTree *string_literal139_tree=nil;
        RewriteRuleTokenStream *stream_ELLIPSIS =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ELLIPSIS"];
        RewriteRuleTokenStream *stream_COMMA =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"];
        RewriteRuleSubtreeStream *stream_namedArg =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule namedArg"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:285:5: ( argExprList | namedArg ( ',' namedArg )* ( ',' '...' )? -> ( namedArg )+ ( '...' )? | '...' |) //ruleblock
        NSInteger alt41=4;
        NSInteger LA41_0 = [input LA:1];

        if ( LA41_0==ID ) {
            NSInteger LA41_1 = [input LA:2];

            if ( ((LA41_1 >= LPAREN && LA41_1 <= RPAREN)||(LA41_1 >= COLON && LA41_1 <= DOT)) ) {
                alt41=1;
            }
            else if ( LA41_1==EQUALS ) {
                alt41=2;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:41 state:1 stream:input];
                nvae.c = LA41_1;
                @throw nvae;

            }
        }
        else if ( (LA41_0==STRING||(LA41_0 >= T_FALSE && LA41_0 <= LBRACK)||LA41_0==SUPER||LA41_0==LCURLY||LA41_0==AT) ) {
            alt41=1;
        }
        else if ( (LA41_0==LPAREN) && ((([conditional_stack count]>0)||([conditional_stack count]==0)))) {
            alt41=1;
        }
        else if ( LA41_0==ELLIPSIS ) {
            alt41=3;
        }
        else if ( LA41_0==RPAREN ) {
            alt41=4;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:41 state:0 stream:input];
            nvae.c = LA41_0;
            @throw nvae;

        }
        switch (alt41) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:285:9: argExprList // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_argExprList_in_args2714];
                argExprList133 = [self argExprList];

                [self popFollow];


                [treeAdaptor addChild:[argExprList133 getTree] toTree:root_0];
                 
                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:286:9: namedArg ( ',' namedArg )* ( ',' '...' )? // alt
                {

                /* ruleRef */
                [self pushFollow:FOLLOW_namedArg_in_args2724];
                namedArg134 = [self namedArg];

                [self popFollow];


                [stream_namedArg addElement:[namedArg134 getTree]];
                 

                do {
                    NSInteger alt39=2;
                    NSInteger LA39_0 = [input LA:1];
                    if ( LA39_0==COMMA ) {
                        NSInteger LA39_1 = [input LA:2];
                        if ( LA39_1==ID ) {
                            alt39=1;
                        }


                    }


                    switch (alt39) {
                        case 1 : ;
                            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:286:20: ',' namedArg // alt
                            {

                            char_literal135=(CommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_args2728];  
                                [stream_COMMA addElement:char_literal135];

                             
                            /* ruleRef */
                            [self pushFollow:FOLLOW_namedArg_in_args2730];
                            namedArg136 = [self namedArg];

                            [self popFollow];


                            [stream_namedArg addElement:[namedArg136 getTree]];
                             
                            }
                            break;

                        default :
                            goto loop39;
                    }
                } while (YES);
                loop39: ;

                 
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:286:36: ( ',' '...' )? // block
                NSInteger alt40=2;
                NSInteger LA40_0 = [input LA:1];

                if ( LA40_0==COMMA ) {
                    alt40=1;
                }
                switch (alt40) {
                    case 1 : ;
                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:286:37: ',' '...' // alt
                        {

                        char_literal137=(CommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_args2736];  
                            [stream_COMMA addElement:char_literal137];

                         
                        string_literal138=(CommonToken *)[self match:input TokenType:ELLIPSIS Follow:FOLLOW_ELLIPSIS_in_args2738];  
                            [stream_ELLIPSIS addElement:string_literal138];

                         
                        }
                        break;

                }

                 
                // AST REWRITE
                // elements: namedArg, ELLIPSIS
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 286:49: -> ( namedArg )+ ( '...' )?
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:286:52: ( namedArg )+
                    {
                    if ( !([stream_namedArg hasNext]) ) {
                        @throw [RewriteEarlyExitException newException];
                    }
                    while ( [stream_namedArg hasNext] ) {
                        [treeAdaptor addChild:[stream_namedArg nextTree] toTree:root_0];

                    }
                    [stream_namedArg reset];

                    }
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:286:62: ( '...' )?
                    if ( [stream_ELLIPSIS hasNext] ) {
                    	 // TODO: args: 
                    	[treeAdaptor addChild:[stream_ELLIPSIS nextNode] toTree:root_0];

                    }
                    [stream_ELLIPSIS reset];

                }


                retval.tree = root_0;


                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:287:9: '...' // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser tokenRef */
                string_literal139=(CommonToken *)[self match:input TokenType:ELLIPSIS Follow:FOLLOW_ELLIPSIS_in_args2758]; 
                string_literal139_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[treeAdaptor create:string_literal139]
                ;
                [treeAdaptor addChild:string_literal139_tree  toTree:root_0];

                 
                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:289:5:  // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_ELLIPSIS = nil;
        stream_COMMA = nil;
        stream_namedArg = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end args */

/*
 * $ANTLR start argExprList
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:291:1: argExprList : arg ( ',' arg )* -> ( arg )+ ;
 */
- (STParser_argExprList_return *) argExprList
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_argExprList_return * retval = [STParser_argExprList_return newSTParser_argExprList_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *char_literal141 = nil;

        STParser_arg_return * arg140 = nil ;

        STParser_arg_return * arg142 = nil ;



        CommonTree *char_literal141_tree=nil;
        RewriteRuleTokenStream *stream_COMMA =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"];
        RewriteRuleSubtreeStream *stream_arg =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule arg"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:291:13: ( arg ( ',' arg )* -> ( arg )+ ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:291:15: arg ( ',' arg )* // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_arg_in_argExprList2777];
        arg140 = [self arg];

        [self popFollow];


        [stream_arg addElement:[arg140 getTree]];
         

        do {
            NSInteger alt42=2;
            NSInteger LA42_0 = [input LA:1];
            if ( LA42_0==COMMA ) {
                alt42=1;
            }


            switch (alt42) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:291:21: ',' arg // alt
                    {

                    char_literal141=(CommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_argExprList2781];  
                        [stream_COMMA addElement:char_literal141];

                     
                    /* ruleRef */
                    [self pushFollow:FOLLOW_arg_in_argExprList2783];
                    arg142 = [self arg];

                    [self popFollow];


                    [stream_arg addElement:[arg142 getTree]];
                     
                    }
                    break;

                default :
                    goto loop42;
            }
        } while (YES);
        loop42: ;

         
        // AST REWRITE
        // elements: arg
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 291:32: -> ( arg )+
        {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:291:35: ( arg )+
            {
            if ( !([stream_arg hasNext]) ) {
                @throw [RewriteEarlyExitException newException];
            }
            while ( [stream_arg hasNext] ) {
                [treeAdaptor addChild:[stream_arg nextTree] toTree:root_0];

            }
            [stream_arg reset];

            }
        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_COMMA = nil;
        stream_arg = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end argExprList */

/*
 * $ANTLR start arg
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:293:1: arg : exprNoComma ;
 */
- (STParser_arg_return *) arg
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_arg_return * retval = [STParser_arg_return newSTParser_arg_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */


        STParser_exprNoComma_return * exprNoComma143 = nil ;




        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:293:5: ( exprNoComma ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:293:7: exprNoComma // alt
        {
        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_exprNoComma_in_arg2800];
        exprNoComma143 = [self exprNoComma];

        [self popFollow];


        [treeAdaptor addChild:[exprNoComma143 getTree] toTree:root_0];
         
        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end arg */

/*
 * $ANTLR start namedArg
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:295:1: namedArg : ID '=' arg -> ^( '=' ID arg ) ;
 */
- (STParser_namedArg_return *) namedArg
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_namedArg_return * retval = [STParser_namedArg_return newSTParser_namedArg_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *ID144 = nil;
        CommonToken *char_literal145 = nil;

        STParser_arg_return * arg146 = nil ;



        CommonTree *ID144_tree=nil;
        CommonTree *char_literal145_tree=nil;
        RewriteRuleTokenStream *stream_EQUALS =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token EQUALS"];
        RewriteRuleTokenStream *stream_ID =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"];
        RewriteRuleSubtreeStream *stream_arg =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule arg"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:295:10: ( ID '=' arg -> ^( '=' ID arg ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:295:12: ID '=' arg // alt
        {

        ID144=(CommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_namedArg2809];  
            [stream_ID addElement:ID144];

         
        char_literal145=(CommonToken *)[self match:input TokenType:EQUALS Follow:FOLLOW_EQUALS_in_namedArg2811];  
            [stream_EQUALS addElement:char_literal145];

         
        /* ruleRef */
        [self pushFollow:FOLLOW_arg_in_namedArg2813];
        arg146 = [self arg];

        [self popFollow];


        [stream_arg addElement:[arg146 getTree]];
         
        // AST REWRITE
        // elements: ID, EQUALS, arg
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil];

        root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

        // 295:23: -> ^( '=' ID arg )
        {
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:295:26: ^( '=' ID arg )
            {
                CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:[stream_EQUALS nextNode] old:root_1];

                 // TODO: args: 
                [treeAdaptor addChild:[stream_ID nextNode] toTree:root_1];

                [treeAdaptor addChild:[stream_arg nextTree] toTree:root_1];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_EQUALS = nil;
        stream_ID = nil;
        stream_arg = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end namedArg */

/*
 * $ANTLR start list
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:297:1: list : ({...}?lb= '[' ']' -> LIST[$lb] |lb= '[' listElement ( ',' listElement )* ']' -> ^( LIST[$lb] ( listElement )* ) );
 */
- (STParser_list_return *) list
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_list_return * retval = [STParser_list_return newSTParser_list_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */
        CommonToken *lb = nil;
        CommonToken *char_literal147 = nil;
        CommonToken *char_literal149 = nil;
        CommonToken *char_literal151 = nil;

        STParser_listElement_return * listElement148 = nil ;

        STParser_listElement_return * listElement150 = nil ;



        CommonTree *lb_tree=nil;
        CommonTree *char_literal147_tree=nil;
        CommonTree *char_literal149_tree=nil;
        CommonTree *char_literal151_tree=nil;
        RewriteRuleTokenStream *stream_RBRACK =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RBRACK"];
        RewriteRuleTokenStream *stream_LBRACK =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LBRACK"];
        RewriteRuleTokenStream *stream_COMMA =
            [RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"];
        RewriteRuleSubtreeStream *stream_listElement =
            [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule listElement"];
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:297:5: ({...}?lb= '[' ']' -> LIST[$lb] |lb= '[' listElement ( ',' listElement )* ']' -> ^( LIST[$lb] ( listElement )* ) ) //ruleblock
        NSInteger alt44=2;
        NSInteger LA44_0 = [input LA:1];

        if ( LA44_0==LBRACK ) {
            NSInteger LA44_1 = [input LA:2];

            if ( LA44_1==RBRACK ) {
                NSInteger LA44_2 = [input LA:3];

                if ( [input LA:2] == RBRACK ) {
                    alt44=1;
                }
                else if ( (YES) ) {
                    alt44=2;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:44 state:2 stream:input];
                    nvae.c = LA44_2;
                    @throw nvae;

                }
            }
            else if ( (LA44_1==ID||LA44_1==STRING||(LA44_1 >= T_FALSE && LA44_1 <= LBRACK)||LA44_1==LPAREN||LA44_1==SUPER||LA44_1==COMMA||LA44_1==LCURLY||LA44_1==AT) ) {
                alt44=2;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:44 state:1 stream:input];
                nvae.c = LA44_1;
                @throw nvae;

            }
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:44 state:0 stream:input];
            nvae.c = LA44_0;
            @throw nvae;

        }
        switch (alt44) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:297:9: {...}?lb= '[' ']' // alt
                {

                if ( !(([input LA:2] == RBRACK)) ) {
                    @throw [FailedPredicateException newException:@"list" predicate:@"[input LA:2] == RBRACK" stream:input];
                }
                 
                lb=(CommonToken *)[self match:input TokenType:LBRACK Follow:FOLLOW_LBRACK_in_list2846];  
                    [stream_LBRACK addElement:lb];

                 
                char_literal147=(CommonToken *)[self match:input TokenType:RBRACK Follow:FOLLOW_RBRACK_in_list2848];  
                    [stream_RBRACK addElement:char_literal147];

                 
                // AST REWRITE
                // elements: 
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 298:20: -> LIST[$lb]
                {
                    [treeAdaptor addChild:[treeAdaptor createTree:LIST FromToken:lb Text:@"LIST"] toTree:root_0];

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:299:9: lb= '[' listElement ( ',' listElement )* ']' // alt
                {

                lb=(CommonToken *)[self match:input TokenType:LBRACK Follow:FOLLOW_LBRACK_in_list2865];  
                    [stream_LBRACK addElement:lb];

                 
                /* ruleRef */
                [self pushFollow:FOLLOW_listElement_in_list2867];
                listElement148 = [self listElement];

                [self popFollow];


                [stream_listElement addElement:[listElement148 getTree]];
                 

                do {
                    NSInteger alt43=2;
                    NSInteger LA43_0 = [input LA:1];
                    if ( LA43_0==COMMA ) {
                        alt43=1;
                    }


                    switch (alt43) {
                        case 1 : ;
                            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:299:30: ',' listElement // alt
                            {

                            char_literal149=(CommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_list2871];  
                                [stream_COMMA addElement:char_literal149];

                             
                            /* ruleRef */
                            [self pushFollow:FOLLOW_listElement_in_list2873];
                            listElement150 = [self listElement];

                            [self popFollow];


                            [stream_listElement addElement:[listElement150 getTree]];
                             
                            }
                            break;

                        default :
                            goto loop43;
                    }
                } while (YES);
                loop43: ;

                 
                char_literal151=(CommonToken *)[self match:input TokenType:RBRACK Follow:FOLLOW_RBRACK_in_list2878];  
                    [stream_RBRACK addElement:char_literal151];

                 
                // AST REWRITE
                // elements: listElement
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 299:53: -> ^( LIST[$lb] ( listElement )* )
                {
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:299:56: ^( LIST[$lb] ( listElement )* )
                    {
                        CommonTree *root_1 = (CommonTree *)[[treeAdaptor class] newEmptyTree];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:[treeAdaptor createTree:LIST FromToken:lb Text:@"LIST"] old:root_1];

                        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:299:68: ( listElement )*
                        while ( [stream_listElement hasNext] ) {
                            [treeAdaptor addChild:[stream_listElement nextTree] toTree:root_1];

                        }
                        [stream_listElement reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        stream_RBRACK = nil;
        stream_LBRACK = nil;
        stream_COMMA = nil;
        stream_listElement = nil;

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end list */

/*
 * $ANTLR start listElement
 * /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:302:1: listElement : ( exprNoComma | -> TNULL );
 */
- (STParser_listElement_return *) listElement
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_listElement_return * retval = [STParser_listElement_return newSTParser_listElement_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        /* ruleLabelDefs entry */


        STParser_exprNoComma_return * exprNoComma152 = nil ;




        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:302:13: ( exprNoComma | -> TNULL ) //ruleblock
        NSInteger alt45=2;
        NSInteger LA45_0 = [input LA:1];

        if ( (LA45_0==ID||LA45_0==STRING||(LA45_0 >= T_FALSE && LA45_0 <= LBRACK)||LA45_0==SUPER||LA45_0==LCURLY||LA45_0==AT) ) {
            alt45=1;
        }
        else if ( (LA45_0==LPAREN) && ((([conditional_stack count]>0)||([conditional_stack count]==0)))) {
            alt45=1;
        }
        else if ( LA45_0==RBRACK||LA45_0==COMMA ) {
            alt45=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:45 state:0 stream:input];
            nvae.c = LA45_0;
            @throw nvae;

        }
        switch (alt45) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:302:15: exprNoComma // alt
                {
                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_exprNoComma_in_listElement2901];
                exprNoComma152 = [self exprNoComma];

                [self popFollow];


                [treeAdaptor addChild:[exprNoComma152 getTree] toTree:root_0];
                 
                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/STParser.g:302:29:  // alt
                {
                // AST REWRITE
                // elements: 
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil];

                root_0 = (CommonTree *)[[treeAdaptor class] newEmptyTree];

                // 302:29: -> TNULL
                {
                    [treeAdaptor addChild:[treeAdaptor createTree:TNULL Text:@"TNULL"] toTree:root_0];

                }


                retval.tree = root_0;


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end listElement */
/* ObjC end rules */

@end /* end of STParser implementation line 692 */
